#	NoSQL
首先需要说明目前常见的NoSQL之间的共性：
	1、对事务的支持很有限；也不支持多join操作。
	2、对复杂查询的支持有限。目前mongoDB应该是能最好地支持多条件查询。
	3、支持的数据量大于传统的关系型数据库,在大数据量的情况下有较好的性能。
	4、在某些场景可以取代传统关系型数据库。大多数情况下稳定性不如关系型数据库。大多数都支持集群操作。

#	MongoDB
##	业务层解耦
		持久化数据。动态监听和数据处理
##	非关系型文件数据库
		存取一些耦合性较低的文档类数据

#	kafka
1、爬虫->服务->算法
##	1、解耦:拆分服务模块

##	2、削峰:
		原本的HTTP请求拆分成kafka消息列队。任务分离,减少阻塞情况发生(同样适用于高并发场景)用缓慢来代替阻塞崩溃

##	3、异步:服务可以同时处理多个任务,而不用去管列队结果
		--事实情况你还得考虑处理结果。利用redis标记状态一直retry是可行的方案。

##	带来的问题:数据一致性问题:
###	重复消费
	保证方法的幂等性。不管消费多少次返回的结果一致性
	缓存设置状态(一直retry)
####	强校验
	分布式事务一致性。一起成功一起回滚
####	弱校验
	一些不重要的场景,把这个id+场景唯一标识作为Redis的key，放到缓存里面(丢失也没有关系)
###	消息丢失
		1、设置auto.commit.enable=false，每次处理完手动提交。确保消息真的被消费并处理完成。
		2、kafka 一定要配置上消息重试的机制，并且重试的时间间隔一定要长一些，默认 1 秒钟不符合生产环境(网络中断时间有可能超过 1秒)。
###	消息的顺序消费
		其实这是个很复杂和严重的场景。一旦请求顺序错误。比如增改查删->增删改查。后果不堪设想
		kafka单线程(只有一个pattern)生产消费是默认有序的。严格要求顺序的场景需要使用一个pattern进行生产

#	Redis
##	数据结构
		String、Hash、List、Set、SortedSet、HyperLogLog、Geo、Pub/Sub、
###		Redis Module 
			BloomFilter，RedisSearch，Redis-ML
####		BloomFilter
##	使用场景
		1、不同微服务之间session共享
		2、热点数据写入Redis降低数据库压力
			设置浏览器级别缓存
			读取数据:有缓存直接返回缓存。没有缓存:读数据库、写入缓存(热点数据放缓存,高频读,低频写)
			写入数据:写数据库,删缓存(更新缓存代价很高)
			双写一致性:
				对于高频写入数据,牺牲实时性换取最终一致性(甚至可以在Java内存中维护原子类)。
			其实删除缓存，而不是更新缓存，就是一个 Lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。
			对于经常更新的热点数据:
		3、标记数据状态,监听分布式事务。
			写入key值,标记状态
			CAS实现非阻塞同步。标记成功状态,是被则一直循环访问

#	ES
##	高速索引
		分词、匹配、倒排索引


#	分布式事务


事务:
##一个服务中,
jconsole跟踪死锁和阻塞
尽量避免重入锁定不同资源,极易造成循环等待。
一次性锁定,一次性释放。
或者单个锁定,单个释放。
串行化
##分布式事务,
一般情况下,放入循环队列,各执行各的。添加retry机制。避免失败。
一致性较强的场景添加通知回滚操作。但是大多数场景不需要,重试多次后失败就失败吧
至于如何回滚呢,一般需要强一致性校验的场景一定会有流水的,或者说是日志。通过日志校验把减掉的再加回来。
避免重复操作问题,redis缓存校验ID。
一致性要求最高的场景,需要排队串行化。
##分布式锁
不同服务中对一个资源的读写操作。
大多数应用于可以牺牲同步实时性,实现最终一致性的场景
如果要求强一致性,就需要牺牲效率。
不同服务分别校验锁资源

双写一致性
1、要么实现强一致性
2、要么实现最终一致性
不阻塞而实时同步的方案是不存在的

复习一:本地方法栈:调用native 方法。可能调用的是非Java编写的程序接口
元空间在直接内存中
常量池在堆中
程序计数器和字节码解释器有关,标记流程化字节码指令:判断、循环等
Class对象在元空间中

synchronized作用域
Redis 持久化 分布式锁 哨兵
分布式事务场景方案

归并排序和分治算法
任务调度线程池
数组翻转,二分
判断树完全二叉树


parallel scavenge initializer Multipart Authentication Concurrent Reentrant