mysql
优化三个方面:
	1、查询优化(sql)
	2、表结构优化
	3、索引优化(INDEX)
一、逻辑架构:
	存储引擎<--(API)--服务器<--(API)--客户端
	服务器通过API与存储引擎之间通信，这些借口可以屏蔽掉不同存储引擎之间的差异。(可以理解为存储引擎实现了服务器所需要的功能接口，虽然底层不同存储引擎的实现方法不同)
	存储引擎:MYISAM、INNODB、ISAM等最为常用。
	mysql服务端客户端通信协议
		MySQL客户端和服务器之间的通信协议是“半双工”的，这意味着，在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。
		客户端一旦向服务端发送了请求，就只能等待服务端返回数据。所以有时候将一个很大的数据传输(或者说大数据查询)切分成一些列小传输是有必要的。

二、ACID基本特性:
	原子性、一致性、隔离性、永久性
	其实ACID都是基于事务和事务产生结果的特性
三、处理并发控制:事务和锁
	1、事务
		事务是一组原子性的SQL查询的集合，是原子性的基本单位。
		事务级别对资源的访问和占有产生锁。事务是由存储引擎负责管理的。(注！！服务器可以为ALTER TABLE语句添加表锁，是服务器级别添加的)
		事务的隔离级别
			1、未提交读READ UNCOMMITTED:
				基本没有隔离，无需提交，所有事务修改可见
			2、提交读READ COMMITTED:
				不同事务间提交可见，不提交不可见
			3、可重复读REPEATABLE READ:
				读取的数据在事务开始和结束不会发生变化。但是其他事务INSERT的数据可见。(无法消除幻读现象)
			4、可串行化:
				完全锁定数据，事务间数据完全隔离。可能会造成严重阻塞
		mysql采用的是，AUTOCOMMIT(自动提交模式)对于INNODB而言，每一条SQL查询都是一个独立的事务。
		事务中混合使用存储引擎:
			mysql服务端不支持管理事务，事务由存储引擎负责实现(重要的事情说三遍)在一个事务中，使用多种存储引擎，这种操作时不可靠的(但是是可行的)
			事务的回滚:在一个包含混合存储引擎的事务中，对于某些不支持事务的存储引擎，回滚事务不会进行操作(例如典型的MYISAM)
	2、锁：
		共享锁(读锁)、排他锁(读锁)
		锁的粒度:行级锁、表锁
		这里有需要注意的是，服务器可以为alter table语句添加表锁，是服务器级别添加的，从而忽略存储引擎级别的锁。行级锁由存储引擎负责管理(INNODB、XTRADB引擎实现了行级锁，MYISAM则不支持)
		INNODB的分段锁机制:在事务的执行过程中随时可以锁定，只有在事务提交COMMIT/ROLLBACK时才会释放锁(并且在事务结束时同时释放所有的锁)
		显式锁定:INNODB利用语句进行显示锁定
			SQL:(不属于SQL规范，尽量避免使用这些SQL，除非你真的认为自己可以处理好这些资源调度)
			SELECT ... LOCK IN SHARE MODE
			SELECT ... FOR UPDATE
			LOCK TABLES语句:在事务之间相互影响可能会产生严重的后果(除非使用AUTOCOMMIT模式，最好在任何存储引擎和情况下都不要使用)

	3、死锁:
		死锁发生的本质是循环等待。不同事务以不同顺序访问同一资源时，访问顺序和释放顺序不同会互相阻塞。
		INNODB目前处理死锁的方法是:将持有最少行级锁(占有资源最少)的事务回滚(死锁发生后，只有部分或完全回滚事务，才能打破死锁)
	4、事务日志:帮助提高事务执行效率
		预写式日志:每次对数据做修改时，需要写两次磁盘。1、记录操作日志，2、将数据同步。
		这样，在事务日志持久化之后，存储引擎可以慢慢将数据同步到磁盘，此时如果服务器崩溃，具体的恢复方式则根据存储引擎而定。
	5、MVCC:多版本并发控制
		你可以将MVCC理解为一个行级锁的变种，降低加锁开销，避免加锁，实现大多数的非阻塞读取操作。需要说明一下不同数据库和存储引擎MVCC实现方式都不同，也没有正误之分。
		INNODB的MVCC实现(了解)
			MVCC只在REPEATABLE READ(可重复读)和READ COMMITTED(提交读)两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容
				InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

四、存储引擎:
	广泛使用的MYISAM和INNODB
	1、INNODB:目前mysql的默认存储引擎。INNODB基于聚簇索引组织并且建立(后面会提到，文件物理存储基于聚簇索引)。
	2、MYISAM:提供了大量的特性，包括全文索引、压缩、空间函数（GIS）等，但MyISAM不支持事务和行级锁(只支持表锁)!!重要缺陷就是崩溃后无法安全恢复。
		注！！不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知的场景中，InnoDB的速度都可以让MyISAM望尘莫及，尤其是使用到聚簇索引，或者需要访问的数据都可以放入内存的应用。
	以下供了解（还有一些未列出）
	3、ARCHIVE:
		只支持INSERT/SELECT操作
	4、Memory:
		1、基于内存创建。重启后数据会丢失(表结构仍然保留)
		2、读取速度比MYISAM快一个等量级。
		3、只支持表锁，不支持行级锁，所以并发写入性能较差。
		4、不支持BLOB和TEXT长文件
		5、人们经常混淆Memory表和临时表。临时表使用CREATE TEMPORARY TABLE语句创建，它可以使用任何存储引擎，临时表只在单个连接可见，当连接断开时，临时表也将不复存在。
	5、NDB集群引擎
五、SCHEMA和数据类型选择
		timestamt(4字节)内存小于datetime(8字节)。
	整数:
		TINYINT 8位		SMALLINT 16位	MEDIUMINT 24位		INT 32位		BIGINT 64位
		INT有可选的UNSIGNED属性，存储无符号型整数
		MySQL可以为整数类型指定宽度，例如INT（11），对大多数应用这是没有意义的：它不会限制值的合法范围，只是规定了MySQL的一些交互工具用来显示字符的个数。对于存储和计算来说，INT（1）和INT（20）是相同的。
	实数:
		FLOAT 4字节 32位
		DOUBLE 8字节 64位
		DECIMAL 可以指定长度和精度。需要额外存储和开销(所以除了需要精确计算的场景，比如财务计算，尽量避免使用decimal)
	字符串:
		CHAR和VARCHAR:
			CHAR:定长字符串
			VARCHAR:可变长字符串
			在存储上，VARCHAR(255)要比CHAR(255)更加节省空间，因为它仅使用必要的空间(越短的字符串越节省空间)但是可能会影响VARCHAR update的效率。
			VARCHAR需要使用1或2个额外字节记录字符串的长度：如果列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用2个字节。假设采用latin1字符集，一个VARCHAR（10）的列需要11个字节的存储空间。VARCHAR（1000）的列则需要1002个字节，因为需要2个字节存储长度信息。
			VARCHAR适用的情况:1、长短不一，最长字符明显大于最短字符；2、列的更新很少
			CHAR适用的情况:1、很短、或者所有字符长度都接近同一个长度2、频繁更新
		BINARY和VARBINARY(了解):
			与CHAR和VARCHAR类似的类型还有BINARY和VARBINARY，它们存储的是二进制字符串。二进制字符串跟常规字符串非常相似，但是二进制字符串存储的是字节码而不是字符。填充也不一样：MySQL填充BINARY采用的是\0（零字节）而不是空格，在检索时也不会去掉填充值(8)。
	长文本
		BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。BLOB和TEXT家族之间仅有的不同是BLOB类型存储的是二进制数据，没有排序规则或字符集，而TEXT类型有字符集和排序规则。
		TINYTEX				TTINYBLOB
		SMALLTEXT(TEXT)		SMALLBLOB(BLOB)
		MEDIUMTEXT			MEDIUMBLOB
		LONGTEXT			LONGBLOB
		1、与其他数据类型不同的是，INNODB将长文本存储在外部，并作为指针链接到每一行数据上。
		2、需要注意的是，长文本不支持全部长度字符串上的索引。也不能使用这些索引进行排序。
	枚举ENUM
		1、ENUM在实际存储上是整数型，然后将整数映射为枚举的字符串!!需要注意的是，ENUM在排序上，也是按照整数型排序，这可能会造成一些困扰。解决问题的方式有两种
			1、按照所需要的顺序来定义枚举。
			2、查询中使用FIELD()函数显式地指定排序顺序，但这会导致MySQL无法利用索引消除排序。
				SELECT e FROM ENUM_TABLE ORDER BY FIELD(e,'apple','banana','dog')
		2、枚举最不好的地方是，字符串列表是固定的，添加或删除字符串必须使用ALTER TABLE。因此，对于一系列未来可能会改变的字符串，使用枚举不是一个好主意，除非能接受只在列表末尾添加元素。
		3、ENUM存储时内存小于VARCHAR
		4、ENUM关联VARCHAR和CHAR可能会造成性能问题(比ENUM关联ENUM、VARCHAR关联VARCHAR慢)所以避免ENUM与字符串相关联
		5、ENUM适用在不经常会改变的类型、且类型不过多
	日期和时间
		1、mysql能保存的最小时间粒度为秒，时间戳为10位(这点和hive一致)。
		2、FROM_UNIXTIME()、UNIX_TIMESTAMP()来转换整数和TIMESTAMP
		3、TIMESTAMP只使用4个字节的存储空间，因此它的范围比DATETIME小得多：只能表示从1970年到2038年。
		4、TIMESTAMP默认格式为NOT NULL，和其他数据不一致。
		5、TIMESTAMP效率优于DATETIME，同时优于INT(所以想用INT整数来优化时间函数是不可行的)
		6、mysql不支持比10位更小粒度的时间戳，如果需要更精确的时间戳(比如精确到毫秒的13位)可以使用BIGINT/DOUBLE等替换时间。
	位数据类型
		BIT:没什么用，不推荐使用
		SET(暂时不想看了)
	数据类型标识符选择:
		1、在相关的表中使用相同的数据类型，不同数据类型之间的关联可能会导致性能问题
		2、MySQL在内部使用整数存储ENUM和SET类型，然后在做比较操作时转换为字符串
		3、存储boolean建议使用CHAR(1)
		4、数据-->越小越好，越简单越好，尽量避免存储null
		5、整数通常是标识列最好的选择，因为它们很快并且可以使用AUTO_INCREMENT。
		6、UUID作为主键其实是失败的设计(尤其在MYISAM中导致6倍以上的性能下降)
		7、避免使用自动生成schema的操作(比如JPA AUTO、JAVA ORM)可能会造成性能噩梦
		8、实际应该使用无符号整数存储IP地址(而不是VARCHAR(15))。MySQL提供INET_ATON()和INET_NTOA()函数在这两种表示方法之间转换。(暂时未测试)
		9、SCHEMA中的问题
			1、避免过多的列
			2、避免过多的关联
			3、避免过大的枚举
	范式与反范式:
		第一范式:列不可再分,关系型基础
		第二范式:在第一范式的基础上，消除部分依赖。非主属性依赖于主键
		第三范式:消除传递依赖(暂时不懂)
		对比范式与反范式
			范式:
				1、消除冗余和重复数据，拆分表属性
				2、更新操作较快
				3、在查询中，往往需要关联表，导致索引不可用；降低查询效率
			反范式:
				1、会有冗余和重复数据，修改和插入时可能需要修改大量重复行；
				2、(INDEX)往往可以提升查询效率；
	汇总表与缓存表的使用:(之后再看吧)
六、索引INDEX	
	INDEX的种类:
		B-Tree INDEX:
			特性:
				1、需要说明一点，实际上存储引擎使用的 B-Tree 索引时B+Tree存储数据。
				2、不同存储引擎使用BTREE索引的方式也不同
					MYISAM B-Tree 根据数据物理存储位置来索引数据，INNODB根据指针(主键)索引数据位置
					MYISAM会压缩BTREE索引前缀使得索引变得更小，INNODB会按照原始数据格式存储索引
				3、B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索(!!所以索引是在存储引擎级别定义和工作的)
				4、B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找
				5、B-Tree索引可以用来:优化查询SELECT、排序ORDER、分组GROUP
			限制:
				最左原则:必须从索引的最左列开始使用索引，且不能跳过索引列;
		HASH INDEX:基于HASH TABLE实现，只有在精确匹配所有索引列时有效
			1、只能等值查询，范围查询时不可使用；
			2、无法用于排序(不是按照值顺序存储)；
			3、可能会造成HASH冲突
			4、哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行(!!!所以不能利用HASH索引来避免资源冲突和死锁)
		R-Tree INDEX(空间索引):MYISAM支持空间索引，了解一下得了
	INDEX有如下三个优点：
		大大减少了服务器需要扫描的数据量。
		可以帮助服务器避免排序和临时表。
		可以将随机I/O变为顺序I/O。
	索引策略
		1、将单独的索引列放到比较符的一侧:
			"WHERE TO_DAYS(CURRENT_DATE)   <= 10 +TO_DAYS(date_col)" 而不是 "WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10"
		2、前缀索引
			对于较长的字段，通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。--同时需要保证索引的选择性不能太低(下一点)
		3、提升索引选择性:
			索引选择性是指
		4、索引不宜过大，不宜过多
			为每个列创建单独的索引，是一个常见的错误
		5、选择合适的索引顺序
			经验法则：将选择性最高的列放到索引最前列
			经验法则考虑的是全局基数和选择性，对于特定查询，可以人为判断选择性
		6、按主键顺序插入行
			UUID作为主键策略真的很糟糕，使聚簇索引的插入完全随机，数据排列规则也遭到破坏
	聚簇索引
		1、聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。!!!可以说在InnoDB中，聚簇索引“就是”表本身。。一张table只能有一个聚簇索引，InnoDB根据聚簇索引将table数据组织在一起。
		2、聚簇索引本身和主键并没有必然联系，InnoDB默认主键为聚簇索引。目前我还不知道mysql有哪个存储引擎支持自定义聚簇索引。
		3、如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。InnoDB只聚集在同一个页面中的记录。包含相邻键值的页面可能会相距甚远。
		4、聚簇索引数据查询方式远比非聚簇索引快。
		5、MyISAM中主键索引和其他索引在结构上没有什么不同。主键索引就是一个名为PRIMARY的唯一非空索引。MyISAM也不依赖聚簇索引组织数据。
		6、InnoDB的二级索引和聚簇索引很不相同。InnoDB二级索引的叶子节点中存储的不是“行指针”，而是主键值，并以此作为指向行的"指针"
	INDEX的覆盖查询:
		如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。这样查询可以只访问索引，而不需要回表查询，减少二次查询，极大提升性能。
	利用INDEX排序:
		排序可与查询公用一个索引，共同符合最左原则。
	索引与锁
		InnoDB只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问的行数，从而减少锁的数量。但这只有当InnoDB在存储引擎层能够过滤掉所有不需要的行时才有效。
		索引可以让查询锁定更少的行。如果你的查询从不访问那些不需要的行，那么就会锁定更少的行，从两个方面来看这对性能都有好处。首先，虽然InnoDB的行锁效率很高，内存使用也很少，但是锁定行的时候仍然会带来额外开销；其次，锁定超过需要的行会增加锁争用并减少并发性。
	索引的弊端:
		对于数据极大的表，索引同样会占据很大的内存空间
		索引会导致update、insert、delete等操作变得很慢
	最后附上一句看不懂的话
		"关于InnoDB、索引和锁有一些很少有人知道的细节：InnoDB在二级索引上使用共享（读）锁，但访问主键索引需要排他（写）锁。这消除了使用覆盖索引的可能性，并且使得SELECT FOR UPDATE比LOCK IN SHARE MODE或非锁定查询要慢很多。"
七、优化查询
	查询可以看作一系列子任务的集合。在一个查询案例中，需要找出拆分子任务，需要找出一些不必要的额外操作、某些操作被额外地重复了很多次、某些操作执行得太慢等。优化查询的目的就是优化子任务、消除不必要的子任务时间花费。
	通常来说，查询的生命周期大致可以按照顺序来看：从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。其中“执行”可以认为是整个生命周期中最重要的阶段，这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组等。
	需要明确的是，上述生命周期并不完整，可能会有一些"意外"或者"额外"的情况发生来阻碍查询(锁等待、I/O瓶颈、内存不足和网络等待等)。
	执行查询的过程:
		1、客户端发送一条查询给服务器
		2、服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段
		3、服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划
			将一个SQL转换成一个执行计划，这包括多个子阶段：解析SQL、预处理、优化SQL执行计划。这个过程中任何错误（例如语法错误）都可能终止查询。
				语法解析器和预处理:	MySQL通过关键字将SQL语句进行解析，并生成一棵对应的“解析树”。MySQL解析器将使用MySQL语法规则验证和解析查询。校验的条件包括
					1、语法规则
					2、数据表和数据列是否存在
					3、别名和列名是否有歧义
				查询优化器:
					语法解析处理之后,由优化器将其转化成执行计划。一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。
					当然,优化器经常会做出一些错误的决定,选择一些错误的执行计划;原因有很多。受到存储引擎统计信息、并发执行、估算成本不一致、存储过程、自定义函数等等因素影响。
					可以用 SHOW STATUS like 'Last_query_cost' 可以查看mysql当前查询的成本
					列出优化器可以正确优化的查询类型:
						1、重新定义关联顺序
						2、一些特定情况下外连接转换为内连接
						3、等价变换规则
							（5=5 AND a>5）---> a>5
							（a<b AND b=c） AND a=5 ---> b>5 AND b=c AND a=5
						4、利用索引去优化MAX\MIN,利用存储引擎(MYISAM维护了变量去存储数据总量)去优化COUNT()
						5、
				数据和索引信息统计:
		4、MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询
			查询执行引擎
		5、将结果返回给客户端
			1、将结果返回给客户端(即便无结果集，也将返回给客户端信息:影响行数、执行时间)
				客户端返回是一个增量、逐步返回的过程。当开始生成第一章数据行，服务端就开始向客户端返回数据;
			2、如果查询可以被缓存,将结果集合存放到查询缓存中;
	优化查询
		1、优化数据访问:
			减少数据"获取"量
				包括访问了额外的数据行、获取了冗余的数据列
					查询不需要的记录
					多表关联时返回多余的列数据
					用怀疑和审视的眼光看待SELECT *
			减少数据"扫描"量
				衡量查询开销的三个指标如下:
					响应时间
					扫描的行数
					返回的行数
				mysql执行计划会告诉你生成结果集共扫描了多少行数据(大部分数据会被WHERE过滤掉，对最终结果集并没有贡献)
				当扫描大量数据只返回少量行的情况，可以尝试以下方法来优化查询
					1、使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了
					2、改变库表结构。例如使用单独的汇总表
					3、重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询
	重构查询方式
	MYSQL查询的限制:
		1、等值传递可能会造成很大的性能问题(并不常见);select in select通常是一个糟糕的选择,会造成多重关联表，外层表数据量极大时会造成极大性能问题；尝试替换成join using;
		2、并行执行:MySQL无法利用多核特性来并行执行查询。很多其他的关系型数据库能够提供这个特性，但是MySQL做不到。
		3、MySQL并不支持哈希关联——MySQL的所有关联都是嵌套循环关联。不过，可以通过建立一个哈希索引来曲线地实现哈希关联。
		4、mysql不支持松散索引扫描;目前mysql只支持按照索引顺序去扫描顺序，MySQL的索引扫描需要先定义一个起点和终点而不能跳过特定行;
		5、对于MIN()和MAX()查询，MySQL的优化做得并不好;我们可以尝试用INDEX + LIMIT来替代MIN/MAX进行优化;
		6、MySQL不允许对同一张表同时进行查询和更新
			UPDATE fire_fighting_equipment
            SET fire_fighting_equipment.count = (SELECT count(*) as num FROM fire_fighting_equipment)
							where id ='10';
			可以替换成以下两种写法,利用临时结果集
			UPDATE fire_fighting_equipment a,(SELECT count(*) as num FROM fire_fighting_equipment) s
            SET a.`count` = s.num
							where a.id ='10';
			UPDATE fire_fighting_equipment a
			cross join  (SELECT count(*) as num FROM fire_fighting_equipment) s 
            SET a.`count` = s.num
							where a.id ='10';		
八、分区和mysql集群
tip:
	1、mysql通过SHOW VARIABLES LIKE '%%'来查看系统变量属性
	2、使用SHOW TABLE STATUS命令（在MySQL 5.0以后的版本中，也可以查询INFORMATION_SCHEMA中对应的表）显示表的相关信息。SHOW TABLE STATUS LIKE '%%'
	3、schema的大小写敏感也与平台有关(windows不敏感，unix敏感)所以在定义schema时养成一个良好的命名习惯可以减少不少麻烦
	4、对于一个select语句，查询缓存-->解析查询-->优化执行查询。如果缓存中可以找到对应查询，服务器就不需要继续去解析查询。
	5、DELIMITER ; 用来制定SQL的分隔符(mysql shell)
	6、SHA1()和MD5()是强加密函数，设计目标是最大限度消除冲突。可以使用如FNV64()函数作为哈希函数，这是移植自Percona Server的函数，可以以插件的方式在任何MySQL版本中使用，哈希值为64位，速度快，且冲突比CRC32()要少很多
	7、可以了解一下后缀索引suffix index。例如，找到某个域名的所有电子邮件地址。MySQL原生并不支持反向索引，但是可以把字符串反转后存储，并基于此建立前缀索引。可以通过触发器来维护这种索引。
	8、	SHOW CREATE TABLE tableName 来查看建表script
		SHOW INDEX FROM tableName查看table index 信息
		ANALYZE TABLE tableName查看table
	9、OPTIMIZE TABLE tableName 来组织和整理table数据
	10、推荐一些小工具:Percona Toolkit
	11、按照ID(主键)顺序进行查询和插入效率会高于随机修改
	12、SHOW FULL PROCESSLIST 可以查看mysql服务的所有连接
		Sleep
		Query
		Locked
		Analyzing and statistics
		Copying to tmp table [on disk]
		The thread is
		Sending data
	13、EXPLAIN EXTENDED 查询执行计划优化改写SQL
	14、直到mysql5.7,select in(selec)仍然是一个很糟糕的选择。会造成表多重关联，外层表数据量极大时会造成极大性能问题;EXISTS和IN并不是一个好的解决问题的方法;所以两者建议均不适用
	15、DISTINCT 和ORDER BY会造成冲突,order by 的属性在 SELECT DISTINCT 中必须存在。
	16、JOIN USING()的用法






