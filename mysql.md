#mysql
##docker 快速启动mysql
###mysql
	步骤:
    	1、docker run -p 3306:3306 --name mysql-server -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=password -d 3cc9613ef3ba

    	2、update user set host ='%' where user='root';

    	3、flush privileges;刷新用户权限

    注意:
    	两个不同的mysql container会造成冲突
    	--net=host 和-p有冲突。如果使用宿主机IP的话,就无法进行端口转发
    	修改mysql密码:mysqladmin -uroot -p123456 password newPassword


##mysql 优化三个方面:
	1、查询优化(sql)
	2、表结构优化
	3、索引优化(INDEX)
	4、软硬件条件(暂时不提)

##一、逻辑架构:
###	存储引擎<--(API)--服务器<--(API)--客户端
####	客户端：
		大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。
####	第二层架构：服务器
		大多数MySQL的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。
####	第三层:存储引擎。
		1、存储引擎负责MySQL中数据的存储和提取。和GNU/Linux下的各种文件系统一样，每个存储引擎都有它的优势和劣势。服务器通过API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎API包含几十个底层函数，用于执行诸如“开始一个事务”或者"根据主键提取一行记录"等操作。但存储引擎不会去解析SQL，不同存储引擎之间也不会相互通信，而只是简单地响应上层服务器的请求。
		2、服务器通过API与存储引擎之间通信，这些借口可以屏蔽掉不同存储引擎之间的差异(可以理解为存储引擎实现了服务器所需要的功能接口，虽然底层不同存储引擎的实现方法不同)
		3、存储引擎接口有着非常丰富的功能,但是底层接口却只有几十个,这些接口像“搭积木”一样能够完成查询的大部分操作。(例如，有一个查询某个索引的第一行的接口，再有一个类似于迭代器查询某个索引条目的下一个条目的功能,有了这两个功能我们就可以完成全索引扫描的操作)这种简单的接口模式，让MySQL的存储引擎插件式架构成为可能，但是正如前面的讨论，也给优化器带来了一定的限制。
		4、常用的存储引擎:MYISAM、INNODB、ISAM等
	
###	mysql服务端客户端通信协议
		MySQL客户端和服务器之间的通信协议是“半双工”的，这意味着，在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。
		客户端一旦向服务端发送了请求，就只能等待服务端返回数据。所以有时候将一个很大的数据传输(或者说大数据查询)切分成一些列小传输是有必要的。

##二、ACID基本特性:
	原子性、一致性、隔离性、永久性
	其实ACID都是基于事务和事务产生结果的特性

##三、处理并发控制:事务和锁
###	1、事务
		事务是一组原子性的SQL查询的集合，是原子性的基本单位。
		事务级别对资源的访问和占有产生锁。事务是由存储引擎负责管理的。(注！！服务器可以为ALTER TABLE语句添加表锁，是服务器级别添加的)
		事务的隔离级别
			1、未提交读READ UNCOMMITTED:
				基本没有隔离，无需提交，所有事务修改可见
			2、提交读READ COMMITTED:
				不同事务间提交可见，不提交不可见
			3、可重复读REPEATABLE READ:
				读取的数据在事务开始和结束不会发生变化。但是其他事务INSERT的数据可见。(无法消除幻读现象)
			4、可串行化:
				完全锁定数据，事务间数据完全隔离。可能会造成严重阻塞
		mysql采用的是，AUTOCOMMIT(自动提交模式)对于INNODB而言，每一条SQL查询都是一个独立的事务。
		事务中混合使用存储引擎:
			mysql服务端不支持管理事务，事务由存储引擎负责实现(重要的事情说三遍)在一个事务中，使用多种存储引擎，这种操作时不可靠的(但是是可行的)
			事务的回滚:在一个包含混合存储引擎的事务中，对于某些不支持事务的存储引擎，回滚事务不会进行操作(例如典型的MYISAM)

###	2、锁：
####	锁的类型:共享锁(读锁)、排他锁(读锁)

####	锁的粒度:行级锁、表锁
			这里有需要注意的是，服务器可以为alter table语句添加表锁，是服务器级别添加的，从而忽略存储引擎级别的锁。行级锁由存储引擎负责管理(INNODB、XTRADB引擎实现了行级锁，MYISAM则不支持)

####	INNODB的分段锁机制:
			在事务的执行过程中随时可以锁定，只有在事务提交COMMIT/ROLLBACK时才会释放锁(并且在事务结束时同时释放所有的锁)

####	显式锁定:INNODB利用语句进行显示锁定
			SQL:(不属于SQL规范，尽量避免使用这些SQL，除非你真的认为自己可以处理好这些资源调度)
			SELECT ... LOCK IN SHARE MODE
			SELECT ... FOR UPDATE
			LOCK TABLES语句:在事务之间相互影响可能会产生严重的后果(除非使用AUTOCOMMIT模式，最好在任何存储引擎和情况下都不要使用)

###	3、死锁:
		死锁发生的本质是循环等待。不同事务以不同顺序访问同一资源时，访问顺序和释放顺序不同会互相阻塞。
		INNODB目前处理死锁的方法是:将持有最少行级锁(占有资源最少)的事务回滚(死锁发生后，只有部分或完全回滚事务，才能打破死锁)

###	4、事务日志:帮助提高事务执行效率
		预写式日志:每次对数据做修改时，需要写两次磁盘。1、记录操作日志，2、将数据同步。
		这样，在事务日志持久化之后，存储引擎可以慢慢将数据同步到磁盘，此时如果服务器崩溃，具体的恢复方式则根据存储引擎而定。

###	5、MVCC:多版本并发控制
		你可以将MVCC理解为一个行级锁的变种，降低加锁开销，避免加锁，实现大多数的非阻塞读取操作。需要说明一下不同数据库和存储引擎MVCC实现方式都不同，也没有正误之分。
		INNODB的MVCC实现(了解)
			MVCC只在REPEATABLE READ(可重复读)和READ COMMITTED(提交读)两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容
				InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

##四、存储引擎:
	广泛使用的MYISAM和INNODB
	1、INNODB:目前mysql的默认存储引擎。INNODB基于聚簇索引组织并且建立(后面会提到，文件物理存储基于聚簇索引)。
	2、MYISAM:提供了大量的特性，包括全文索引、压缩、空间函数（GIS）等，但MyISAM不支持事务和行级锁(只支持表锁)!!重要缺陷就是崩溃后无法安全恢复。
		注！！不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知的场景中，InnoDB的速度都可以让MyISAM望尘莫及，尤其是使用到聚簇索引，或者需要访问的数据都可以放入内存的应用。
	以下供了解（还有一些未列出）
	3、ARCHIVE:
		只支持INSERT/SELECT操作
	4、Memory:
		1、基于内存创建。重启后数据会丢失(表结构仍然保留)
		2、读取速度比MYISAM快一个等量级。
		3、只支持表锁，不支持行级锁，所以并发写入性能较差。
		4、不支持BLOB和TEXT长文件
		5、人们经常混淆Memory表和临时表。临时表使用CREATE TEMPORARY TABLE语句创建，它可以使用任何存储引擎，临时表只在单个连接可见，当连接断开时，临时表也将不复存在。
	5、NDB集群引擎

##五、SCHEMA和数据类型选择
		timestamt(4字节)内存小于datetime(8字节)。
###	整数:
		TINYINT 8位		SMALLINT 16位	MEDIUMINT 24位		INT 32位		BIGINT 64位
		INT有可选的UNSIGNED属性，存储无符号型整数
		MySQL可以为整数类型指定宽度，例如INT（11），对大多数应用这是没有意义的：它不会限制值的合法范围，只是规定了MySQL的一些交互工具用来显示字符的个数。对于存储和计算来说，INT（1）和INT（20）是相同的。

###	实数:
		FLOAT 4字节 32位
		DOUBLE 8字节 64位
		DECIMAL 可以指定长度和精度。需要额外存储和开销(所以除了需要精确计算的场景，比如财务计算，尽量避免使用decimal)
		在float使用中发现的问题
			需要说明float需要指明精度位数,否则进行函数运算时可能出现显示问题


###	字符串:
		CHAR和VARCHAR:
			CHAR:定长字符串
			VARCHAR:可变长字符串
			在存储上，VARCHAR(255)要比CHAR(255)更加节省空间，因为它仅使用必要的空间(越短的字符串越节省空间)但是可能会影响VARCHAR update的效率。
			VARCHAR需要使用1或2个额外字节记录字符串的长度：如果列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用2个字节。假设采用latin1字符集，一个VARCHAR（10）的列需要11个字节的存储空间。VARCHAR（1000）的列则需要1002个字节，因为需要2个字节存储长度信息。
			VARCHAR适用的情况:1、长短不一，最长字符明显大于最短字符；2、列的更新很少
			CHAR适用的情况:1、很短、或者所有字符长度都接近同一个长度2、频繁更新

###		BINARY和VARBINARY(了解):
			与CHAR和VARCHAR类似的类型还有BINARY和VARBINARY，它们存储的是二进制字符串。二进制字符串跟常规字符串非常相似，但是二进制字符串存储的是字节码而不是字符。填充也不一样：MySQL填充BINARY采用的是\0（零字节）而不是空格，在检索时也不会去掉填充值(8)。

###	长文本
		BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。BLOB和TEXT家族之间仅有的不同是BLOB类型存储的是二进制数据，没有排序规则或字符集，而TEXT类型有字符集和排序规则。
		TINYTEX				TTINYBLOB
		SMALLTEXT(TEXT)		SMALLBLOB(BLOB)
		MEDIUMTEXT			MEDIUMBLOB
		LONGTEXT			LONGBLOB
		1、与其他数据类型不同的是，INNODB将长文本存储在外部，并作为指针链接到每一行数据上。
		2、需要注意的是，长文本不支持全部长度字符串上的索引。也不能使用这些索引进行排序。

###	枚举ENUM
		1、ENUM在实际存储上是整数型，然后将整数映射为枚举的字符串!!需要注意的是，ENUM在排序上，也是按照整数型排序，这可能会造成一些困扰。解决问题的方式有两种
			1、按照所需要的顺序来定义枚举。
			2、查询中使用FIELD()函数显式地指定排序顺序，但这会导致MySQL无法利用索引消除排序。
				SELECT e FROM ENUM_TABLE ORDER BY FIELD(e,'apple','banana','dog')
		2、枚举最不好的地方是，字符串列表是固定的，添加或删除字符串必须使用ALTER TABLE。因此，对于一系列未来可能会改变的字符串，使用枚举不是一个好主意，除非能接受只在列表末尾添加元素。
		3、ENUM存储时内存小于VARCHAR
		4、ENUM关联VARCHAR和CHAR可能会造成性能问题(比ENUM关联ENUM、VARCHAR关联VARCHAR慢)所以避免ENUM与字符串相关联
		5、ENUM适用在不经常会改变的类型、且类型不过多

###	日期和时间
		1、mysql能保存的最小时间粒度为秒，时间戳为10位(这点和hive一致)。
		2、FROM_UNIXTIME()、UNIX_TIMESTAMP()来转换整数和TIMESTAMP
		3、TIMESTAMP只使用4个字节的存储空间，因此它的范围比DATETIME小得多：只能表示从1970年到2038年。
		4、TIMESTAMP默认格式为NOT NULL，和其他数据不一致。
		5、TIMESTAMP效率优于DATETIME，同时优于INT(所以想用INT整数来优化时间函数是不可行的)
		6、mysql不支持比10位更小粒度的时间戳，如果需要更精确的时间戳(比如精确到毫秒的13位)可以使用BIGINT/DOUBLE等替换时间。

###	位数据类型
		BIT:没什么用，不推荐使用
		SET(暂时不想看了)

###	数据类型标识符选择:
		1、在相关的表中使用相同的数据类型，不同数据类型之间的关联可能会导致性能问题
		2、MySQL在内部使用整数存储ENUM和SET类型，然后在做比较操作时转换为字符串
		3、存储boolean建议使用CHAR(1)
		4、数据-->越小越好，越简单越好，尽量避免存储null
		5、整数通常是标识列最好的选择，因为它们很快并且可以使用AUTO_INCREMENT。
		6、UUID作为主键其实是失败的设计(尤其在MYISAM中导致6倍以上的性能下降)
		7、避免使用自动生成schema的操作(比如JPA AUTO、JAVA ORM)可能会造成性能噩梦
		8、实际应该使用无符号整数存储IP地址(而不是VARCHAR(15))。MySQL提供INET_ATON()和INET_NTOA()函数在这两种表示方法之间转换。(暂时未测试)
		9、SCHEMA中的问题
			1、避免过多的列
			2、避免过多的关联
			3、避免过大的枚举

###	范式与反范式:
		第一范式:列不可再分,关系型基础
		第二范式:在第一范式的基础上，消除部分依赖。非主属性依赖于主键
		第三范式:消除传递依赖(暂时不懂)
		对比范式与反范式
			范式:
				1、消除冗余和重复数据，拆分表属性
				2、更新操作较快
				3、在查询中，往往需要关联表，导致索引不可用；降低查询效率
			反范式:
				1、会有冗余和重复数据，修改和插入时可能需要修改大量重复行；
				2、(INDEX)往往可以提升查询效率;

###	汇总表与缓存表的使用:(之后再看吧)

##六、索引INDEX	

###	INDEX的种类:
####	B-Tree INDEX:
			特性:
				1、需要说明一点，实际上存储引擎使用的 B-Tree 索引时B+Tree存储数据。
				2、不同存储引擎使用BTREE索引的方式也不同
					MYISAM B-Tree 根据数据物理存储位置来索引数据，INNODB根据指针(主键)索引数据位置
					MYISAM会压缩BTREE索引前缀使得索引变得更小，INNODB会按照原始数据格式存储索引
				3、B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索(!!所以索引是在存储引擎级别定义和工作的)
				4、B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找
				5、B-Tree索引可以用来:优化查询SELECT、排序ORDER、分组GROUP
			限制:
				最左原则:必须从索引的最左列开始使用索引，且不能跳过索引列;
####	HASH INDEX:基于HASH TABLE实现，只有在精确匹配所有索引列时有效
			1、只能等值查询，范围查询时不可使用；
			2、无法用于排序(不是按照值顺序存储)；
			3、可能会造成HASH冲突
			4、哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行(!!!所以不能利用HASH索引来避免资源冲突和死锁)
####	R-Tree INDEX(空间索引):MYISAM支持空间索引，了解一下得了

###	INDEX有如下三个优点：
		大大减少了服务器需要扫描的数据量。
		可以帮助服务器避免排序和临时表。
		可以将随机I/O变为顺序I/O。

###	索引策略
####	1、将单独的索引列放到比较符的一侧:
			```
			WHERE TO_DAYS(CURRENT_DATE)   <= 10 +TO_DAYS(date_col)" 而不是 "WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10
			```
####	2、前缀索引
			对于较长的字段，通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。--同时需要保证索引的选择性不能太低(下一点)
####	3、提升索引选择性:
			索引选择性是指
####	4、索引不宜过大，不宜过多
			为每个列创建单独的索引，是一个常见的错误
####	5、选择合适的索引顺序
			经验法则：将选择性最高的列放到索引最前列
			经验法则考虑的是全局基数和选择性，对于特定查询，可以人为判断选择性
####	6、按主键顺序插入行
			UUID作为主键策略真的很糟糕，使聚簇索引的插入完全随机，数据排列规则也遭到破坏
###	聚簇索引
		1、聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。!!!可以说在InnoDB中，聚簇索引“就是”表本身。。一张table只能有一个聚簇索引，InnoDB根据聚簇索引将table数据组织在一起。
		2、聚簇索引本身和主键并没有必然联系，InnoDB默认主键为聚簇索引。目前我还不知道mysql有哪个存储引擎支持自定义聚簇索引。
		3、如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。InnoDB只聚集在同一个页面中的记录。包含相邻键值的页面可能会相距甚远。
		4、聚簇索引数据查询方式远比非聚簇索引快。
		5、MyISAM中主键索引和其他索引在结构上没有什么不同。主键索引就是一个名为PRIMARY的唯一非空索引。MyISAM也不依赖聚簇索引组织数据。
		6、InnoDB的二级索引和聚簇索引很不相同。InnoDB二级索引的叶子节点中存储的不是“行指针”，而是主键值，并以此作为指向行的"指针"
###	INDEX的覆盖查询:
		如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。这样查询可以只访问索引，而不需要回表查询，减少二次查询，极大提升性能。
###	利用INDEX排序:
		排序可与查询公用一个索引，共同符合最左原则。
		USE INDEX、IGNORE INDEX和FORCE INDEX
		这几个提示会告诉优化器使用或者不使用哪些索引来查询记录。MyQL 5.1和之后的版本可以通过新增选项FOR ORDER BY和FOR GROUP BY来指定是否对排序和分组有效。
###	索引与锁
		InnoDB只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问的行数，从而减少锁的数量。但这只有当InnoDB在存储引擎层能够过滤掉所有不需要的行时才有效。
		索引可以让查询锁定更少的行。如果你的查询从不访问那些不需要的行，那么就会锁定更少的行，从两个方面来看这对性能都有好处。首先，虽然InnoDB的行锁效率很高，内存使用也很少，但是锁定行的时候仍然会带来额外开销；其次，锁定超过需要的行会增加锁争用并减少并发性。
###	索引的弊端:
		1、对于数据极大的表，索引同样会占据很大的内存空间
		2、索引会导致update、insert、delete等操作变得很慢
###	最后附上一句看不懂的话
		"关于InnoDB、索引和锁有一些很少有人知道的细节：InnoDB在二级索引上使用共享（读）锁，但访问主键索引需要排他（写）锁。这消除了使用覆盖索引的可能性，并且使得SELECT FOR UPDATE比LOCK IN SHARE MODE或非锁定查询要慢很多。"
####	访问主键索引是需要排他锁的
##七、优化查询
	查询可以看作一系列子任务的集合。在一个查询案例中，需要找出拆分子任务，需要找出一些不必要的额外操作、某些操作被额外地重复了很多次、某些操作执行得太慢等。优化查询的目的就是优化子任务、消除不必要的子任务时间花费。
	通常来说，查询的生命周期大致可以按照顺序来看：从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。其中“执行”可以认为是整个生命周期中最重要的阶段，这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组等。
	
	需要明确的是，上述生命周期并不完整，可能会有一些"意外"或者"额外"的情况发生来阻碍查询(锁等待、I/O瓶颈、内存不足和网络等待等)。
	
###	执行查询的过程:
		1、客户端发送一条查询给服务器
		2、服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段
		3、服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划
			将一个SQL转换成一个执行计划，这包括多个子阶段：解析SQL、预处理、优化SQL执行计划。这个过程中任何错误（例如语法错误）都可能终止查询。
				语法解析器和预处理:	MySQL通过关键字将SQL语句进行解析，并生成一棵对应的“解析树”。MySQL解析器将使用MySQL语法规则验证和解析查询。校验的条件包括
					1、语法规则
					2、数据表和数据列是否存在
					3、别名和列名是否有歧义
				查询优化器:
					1、语法解析处理之后,由优化器将其转化成执行计划。一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。
					2、当然,优化器经常会做出一些错误的决定,选择一些错误的执行计划;原因有很多。受到存储引擎统计信息、并发执行、估算成本不一致、存储过程、自定义函数等等因素影响。
					3、可以用 SHOW STATUS like 'Last_query_cost' 可以查看mysql当前查询的成本
					4、列出优化器可以正确优化的查询类型(当然远远不止以下这些，作为了解):
						1、重新定义关联顺序
							1、mysql如何执行关联查询:
								mysql认为，所有的查询、每一个片段都是关联(并不仅仅是多个表之间的查询叫做关联)
								当前MySQL关联执行的策略很简单：MySQL对任何关联都执行嵌套循环关联操作。MySQL先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为止。然后根据各个表匹配的行，返回查询中需要的各个列。
								任何关联都可以用一棵树型结构表示(我个人更理解为不同集合的U|交集并集)mysql生成结果集的顺序是左侧深度优先
							2、通过执行计划可以看到,mysql时常会重新定义关联顺序。
								不同的关联顺序循环次数会有明显优劣。关联优化器会尝试在所有的关联顺序中选择一个成本最小的来生成执行计划树。
								如果可能，优化器会遍历每一个表然后逐个做嵌套循环计算每一棵可能的执行计划树的成本，最后返回一个最优的执行计划。
							3、查看最大可关联的表数量:show VARIABLES like  'optimizer_search_depth' 当需要关联的表超过限制的时候，就会选择“贪婪”搜索模式了。可手动修改参数
							4、如果优化器优化顺序并不为最优,可以使用STRAIGHT_JOIN重构。
						2、一些特定情况下外连接转换为内连接
						3、等价变换规则
							（5=5 AND a>5）---> a>5
							（a<b AND b=c） AND a=5 ---> b>5 AND b=c AND a=5
						4、利用索引去优化MAX\MIN,利用存储引擎(MYISAM维护了变量去存储数据总量)去优化COUNT()
						5、有时候查询可以转化为一个常数:1、关联查询中一些主键2、索引查询中MIN()等等。USING、ON等子句也可以限制某列取值为常数
						6、覆盖索引扫描
						7、子查询优化(例如IN)
						8、一些符合条件值的提前终止查询LIMIT/DISTINCT/EXIST
						9、等值传播: on t1.id=t2.id where t1.id>500 ---> on t1.id=t2.id where t1.id>500 and t2.id>500
							而且MYSQL不建议按照后者编写SQL，MYSQL可以自动进行等值传播，后者写法反而提升查询维护的成本
						10、对于IN()列表中有大量取值的时候，MySQL的处理速度将会更快
		4、MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询
			1、MySQL只是简单地根据执行计划给出的指令逐步执行。在根据执行计划逐步执行的过程中，有大量的操作需要通过调用存储引擎实现的接口来完成。也就是handle API 接口。
			2、查询中的每一个表由一个handler的实例表示。实际上,MySQL在优化阶段就为每个表创建了一个handler实例,优化器根据这些实例的接口可以获取表的相关信息,包括表的所有列名、索引统计信息等等。
			3、值得一提的是,INNODB等行级锁的实现就是基于handle实例。
			查询执行引擎
		5、将结果返回给客户端
			1、将结果返回给客户端(即便无结果集，也将返回给客户端信息:影响行数、执行时间)
				客户端返回是一个增量、逐步返回的过程。当开始生成第一章数据行，服务端就开始向客户端返回数据;
			2、如果查询可以被缓存,将结果集合存放到查询缓存中;
###		查询优化器的提示(是个重点):
			如果对优化器选择的执行计划不满意，可以使用优化器提供的几个提示（hint）来控制最终的执行计划。
			尽量避免去在优化器面前耍一些小聪明,除非你真的认为自己已经有超越优化器的能力。
####		1、HIGH_PRIORITY和LOW_PRIORITY
				这个提示告诉MySQL，当多个语句同时访问某一个表的时候，哪些语句的优先级相对高些、哪些语句的优先级相对低些。
				HIGH_PRIORITY用于SELECT语句的时候，MySQL会将此SELECT语句重新调度到所有正在等待表锁以便修改数据的语句之前。
				LOW_PRIORITY则正好相反：它会让该语句一直处于等待状态，只要队列中还有需要访问同一个表的语句——即使是那些比该语句还晚提交到服务器的语句。

####		2、DELAYED
				这个提示对INSERT和REPLACE有效。MySQL会将使用该提示的语句立即返回给客户端，并将插入的行数据放入到缓冲区，然后在表空闲时批量将数据写入。

####		3、STRAIGHT_JOIN
				1、查询中所有的表按照在语句中出现的顺序进行关联。
				2、固定其前后两个表的关联顺序。

####		4、SQL_SMALL_RESULT和SQL_BIG_RESULT
				这两个提示只对SELECT语句有效。它们告诉优化器对GROUP BY或者DISTINCT查询如何使用临时表及排序。SQL_SMALL_RESULT告诉优化器结果集会很小，可以将结果集放在内存中的索引临时表，以避免排序操作。如果是SQL_BIG_RESULT，则告诉优化器结果集可能会非常大，建议使用磁盘临时表做排序操作。

####		5、SQL_BUFFER_RESULT
				这个提示告诉优化器将查询结果放入到一个临时表，然后尽可能快地释放表锁。这和前面提到的由客户端缓存结果不同。
				带来的好处是无须在客户端上消耗太多的内存，还可以尽可能快地释放对应的表锁。代价是，服务器端将需要更多的内存。

####		6、SQL_CACHE和SQL_NO_CACHE
				提示mysql优化器这个结果集是否应该缓存在查询缓存中

####		7、SQL_CALC_FOUND_ROWS
			

####		8、FOR UPDATE和LOCK IN SHARE MODE
				1、这两个提示主要控制SELECT语句的锁机制，但只对实现了行级锁的存储引擎有效(INNODB)
				2、对于INSERT...SELECT语句是不需要这两个提示的,引擎会自动为INSERT语句加锁
				3、这两个提示会迫使某些优化无法正常使用,例如索引覆盖扫描。InnoDB不能在不访问主键的情况下排他地锁定行，因为行的版本信息保存在主键中。
				4、应当尽量避免这两个提示器的使用
####		9、USE INDEX、IGNORE INDEX和FORCE INDEX
				新增选项FOR ORDER BY和FOR GROUP BY来指定是否对排序和分组有效。
###	优化查询:
		1、优化数据访问:
			减少数据"获取"量
				包括访问了额外的数据行、获取了冗余的数据列
					查询不需要的记录
					多表关联时返回多余的列数据
					用怀疑和审视的眼光看待SELECT *
			减少数据"扫描"量
				衡量查询开销的三个指标如下:
					响应时间
					扫描的行数
					返回的行数
				mysql执行计划会告诉你生成结果集共扫描了多少行数据(大部分数据会被WHERE过滤掉，对最终结果集并没有贡献)
				当扫描大量数据只返回少量行的情况，可以尝试以下方法来优化查询
					1、使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了
					2、改变库表结构。例如使用单独的汇总表
					3、重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询

###	ORDER排序优化:
		1、mysql可以使用INDEX排序时,EXPLAIN extra中不会出现filesort。
		2、当无法使用索引进行排序的时候,MySQL需要自己进行排序，如果数据量小则在内存中进行，如果数据量大则需要使用磁盘，这个过程统一称为文件排序（filesort），无论在内存或是磁盘中都是如此。
		3、需要注意的是，order操作在进行文件排序时使用的临时存储空间可能会非常巨大。mysql在排序时会给每个字段预留一段充足的空间去存储。不恰当地使用文件排序，可能导致临时表比table大好多倍
		4、关联查询时使用order操作时,如果排序字段全部来自第一张关联表,则using filesort.如果来自多张关联表,则还会using temporary。所以避免使用不同表中不同字段排序。
		排序的两种执行方式:
			两种方式配合使用,各有优劣。“当查询需要所有列的总长度不超过参数max_length_for_sort_data时，MySQL使用“单次传输排序”,反之使用两次传输排序。
			MySQL5.6在这里做了很多重要的改进:
					当只需要返回部分排序结果的时候,例如使用了LIMIT子句，MySQL不再对所有的结果进行排序，而是根据实际情况，选择抛弃不满足条件的结果，然后再进行排序。
			1、两次传输排序
				读取行指针和需要排序的字段，对其进行排序，然后再根据排序结果读取所需要的数据行。这需要进行两次数据传输，即需要从数据表中读取两次数据。
				缺点:
					因为是读取排序列进行排序后的所有记录，这会产生大量的随机I/O，所以两次数据传输的成本非常高。
					当使用的是MyISAM表的时候，成本可能会更高，因为MyISAM使用系统调用进行数据的读取(MyISAM非常依赖操作系统对数据的缓存)
				优点:
					在排序的时候存储尽可能少的数据，这就让“排序缓冲区”中可能容纳尽可能多的行数进行排序。
			2、单次传输排序:
				先读取查询所需要的所有列，然后再根据给定列进行排序，最后直接返回排序结果。
				优点:
					这个算法只在MySQL 4.1和后续更新的版本才引入。因为不再需要从数据表中读取两次数据，对于I/O密集型的应用，这样做的效率高了很多。
					这个算法只需要一次顺序I/O读取所有的数据，而无须任何的随机I/O。
				缺点:
					如果需要返回的列非常多、非常大，会额外占用大量的空间，而这些列对排序操作本身来说是没有任何作用的。因为单条排序记录很大，所以可能会有更多的排序块需要合并。
###	COUNT的优化:
		1.可以使用覆盖索引,扫描特定行数据,不回表操作;
		2.MYISAM COUNT(*) from table 是一个常量;此时不能有WHERE condition
			在已知ID>5要远远大于ID<5的情况下,可以如下改写,减少扫描的数据
			mysql> SELECT COUNT（*） FROM world.City WHERE ID>5;修改为--->
			SELECT (SELECT COUNT(*) FROM world.City) - COUNT(*) FROM world.City WHERE ID <= 5;
		3.不需要精确统计的情况下,尝试去除distinct(例如统计实时在线人数ID等)
		4.不需要及时性和精确性的情况下,建立统计表
###	关联查询的优化:
		1、确保ON或者USING子句中的列上有索引
		2、确保任何的GROUP BY和ORDER BY中的表达式只涉及到一个表中的列，这样MySQL才有可能使用索引来优化这个过程。
###	GROUP BY
		show VARIABLES like 'SQL_MODE' 可设置分组查询GROUP BY和分组列的对应
		1、建议使用分组列进行分组查询,也就是SELECT和GROUP BY 后的字段是一样的
			在分组查询的SELECT中直接使用非分组列通常都不是什么好主意，因为这样的结果通常是不定的，当索引改变，或者优化器选择不同的优化策略时都可能导致结果不一样。
			建议将MySQL的SQL_MODE设置为包含ONLY_FULL_GROUP_BY，这时MySQL会对这类查询直接返回一个错误，提醒你需要重写这个查询。
		2、没有通过ORDER BY子句显式地指定排序列，当查询使用GROUP BY，结果集会自动按照分组的字段进行排序。如果不关心结果集的顺序,而这种默认排序又导致了需要文件排序，则可以使用ORDER BY NULL消除filesort。也可以在GROUP BY子句中直接使用DESC或者ASC关键字，使分组的结果集按需要的方向排序。
		3、GROUP可以使用INDEX字段
		4、可以消除掉某些MAX()、MIN()操作
###	GROUP BY WITH ROLLUP
		尽量消除这种用法,将聚合之后的超级聚合放到应用程序中

###	LIMIT 分页的优化策略
		1、可以使用覆盖索引找出ID之后反JOIN需要排序表;
		2、可以新增排序列(这个时候递增主键可以发挥作用),并且记录当前排序键值的位置,那么可以根据最新一条记录向后追溯。或者手动计算出数据序号
		3、其他优化办法还包括使用预先计算的汇总表，或者关联到一个冗余表，冗余表只包含主键列和需要做排序的数据列。还可以使用Sphinx优化一些搜索操作

###优化SQL_CALC_FOUND_ROWS

###优化UNION查询
		MySQL总是通过创建并填充临时表的方式来执行UNION查询。因此很多优化策略在UNION查询中都没法很好地使用。
		1、手工地将WHERE、LIMIT、ORDER BY等子句“下推”到UNION的各个子查询中，以便优化器可以充分利用这些条件进行优化(虽然这么做通常显得不够优雅)
		2、除非很必要,尽量替换UNION 为UNION ALL

###关于用户自定义变量的使用
####	一些特性和局限性
		1、使用自定义变量的查询，无法使用查询缓存。
		2、不能在使用常量或者标识符的地方使用自定义变量，例如表名、列名和LIMIT子句中。
		3、用户自定义变量的生命周期是在一个连接中有效
		4、自定义变量在MYSQL5.0之前是大小写敏感的
		5、赋值符号:=的优先级非常低，所以需要注意，赋值表达式应该使用明确的括号。
		6、赋值的时间节点经常会是不固定的,依赖于优化器的决定;经常会造成困惑
		7、优化器某些场景可能会将自定义变量优化掉
####	一些使用
		Set设置的变量在会话范围内有效，为会话变量，且会话变量命名只能以@开头。
		DECLARE只能用于函数和存储过程中。在调用存储过程时，以DECLARE声明的变量都会被初始化为 NULL

#####	针对以上第6点,单独说明
		SELECT、WHERE、ORDER在查询的不同时段被执行,所以不要期望去做一些如下所示的操作
		SET @rownum := 0;
		SELECT actor_id, @rownum := @rownum + 1 AS cnt
        -> FROM sakila.actor
        -> WHERE @rownum <= 1 ORDER BY first_name"
        上面语句会返回所有数据。因为“WHERE条件是在文件排序操作之前取值的
        尽量将赋值和取值的放在同一语句中,甚至最好是同一()中: WHERE (@rownum := @rownum + 1)<=10
		引入例如	LEAST(0, @rownum := @rownum + 1) 的操作,使得赋值不会影响要查询和返回的值

####	一些使用场景
		1、实现ROW_NUMBER
		2、避免重复查询刚刚更新的数据
		3、ON DUPLICATE KEY UPDATE 情况下统计插入和更新的数量
		4、设置 UNION 的短路操作
			"SELECT GREATEST(@found := −1, id) AS id, 'users' AS which_tbl
    		 FROM users WHERE id = 1
    		 UNION ALL
      		 SELECT id, 'users_archived'
      		 FROM users_archived WHERE id = 1 AND @found IS NULL
    		 UNION ALL
      		 SELECT 1, 'reset' FROM DUAL WHERE ( @found := NULL ) IS NOT NULL;"
#####   接下来这段话没太看懂,以后再慢慢看吧
		有时，优化器会把变量当作一个编译时常量来对待，而不是对其进行赋值。将函数放在类似于LEAST()这样的函数中通常可以避免这样的问题。另一个办法是在查询被执行前检查变量是否被赋值。不同的场景下使用不同的办法。
      	查询运行时计算总数和平均值。
		模拟GROUP语句中的函数FIRST()和LAST()。
		对大量数据做一些数据计算。
		计算一个大表的MD5散列值。
		编写一个样本处理函数，当样本中的数值超过某个边界值的时候将其变成0。
		模拟读/写游标。
		在SHOW语句的WHERE子句中加入变量值。

###	MYSQL查询的限制:
		1、等值传递可能会造成很大的性能问题(并不常见);
		2、关联子查询select in select通常是一个糟糕的选择,会造成多重关联表，外层表数据量极大时会造成极大性能问题；尝试替换成join using;
		3、并行执行:MySQL无法利用多核特性来并行执行查询。很多其他的关系型数据库能够提供这个特性，但是MySQL做不到。
		4、MySQL并不支持哈希关联——MySQL的所有关联都是嵌套循环关联。不过，可以通过建立一个哈希索引来曲线地实现哈希关联。
		5、mysql不支持松散索引扫描;目前mysql只支持按照索引顺序去扫描顺序，MySQL的索引扫描需要先定义一个起点和终点而不能跳过特定行;
		6、对于MIN()和MAX()查询，MySQL的优化做得并不好;我们可以尝试用INDEX + LIMIT来替代MIN/MAX进行优化;
		7、MySQL不允许对同一张表同时进行查询和更新
		```
			UPDATE fire_fighting_equipment
            SET fire_fighting_equipment.count = (SELECT count(*) as num FROM t1)
							where id ='10';
		```
			可以替换成以下两种写法,利用临时结果集
			```
			UPDATE fire_fighting_equipment a,(SELECT count(*) as num FROM t1) s
            SET a.`count` = s.num
							where a.id ='10';
		```
		```
			UPDATE fire_fighting_equipment a
			cross join  (SELECT count(*) as num FROM t1) s 
            SET a.`count` = s.num
							where a.id ='10';		
		```
##八、分区表
###	一些特性
	1、分区表是一个独立的逻辑表，但是底层由多个物理子表组成。实现分区的代码实际上是对一组底层表的句柄对象（Handler Object）的封装。
	2、对于存储引擎来说,它不会关心handle 对象是分区表的子表还是独立的物理表,实际情况中两种对于存储引擎来说是一致的。
	3、所以对于分区表来说,没有全局索引。
	4、存储引擎管理分区的各个底层表和管理普通表一样(所有的底层表都必须使用相同的存储引擎)
	5、在进行SELECT/UPDATE/INSERT/DELETE操作时,分区层先打开并锁住所有的底层表,然后确定对应哪个分区修改这条记录,再将记录写入对应底层表。
	6、需要注意分层区也并不是需要打开和锁定所有的底层表,如果存储引擎能够实现行级锁,例如InnoDB，则会在分区层释放对应表锁。这个加锁和解锁过程与普通InnoDB上的查询类似

###	一些限制
		1、一个表最多只能有1024个分区。
		2、在MySQL 5.1中，分区表达式必须是整数，或者是返回整数的表达式。在MySQL 5.5中，某些场景中可以直接使用列来进行分区。
		3、如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来。
		4、分区表中无法使用外键约束。

###	一些场景
		1、表非常大以至于无法全部都放在内存中，或者只在表的最后部分有热点数据，其他均是历史数据。
		2、分区表的数据更容易维护。例如，想批量删除大量数据可以使用清除整个分区的方式。另外，还可以对一个独立分区进行优化、检查、修复等操作。
		3、分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。
		4、可以使用分区表来避免某些特殊的瓶颈，例如InnoDB的单个索引的互斥访问、ext3文件系统的inode锁竞争等。
		5、还可以备份和恢复独立的分区，这在非常大的数据集的场景下效果非常好。

###	如何使用

##九、其他高级特性
###	视图
###	事件、存储过程、函数
###	关于外键
		1、InnoDB是目前MySQL中唯一支持外键的内置存储引擎
		2、外键成本:在修改数据时都会要求在外键关联表中多做一次查找操作,这种约束检查可能会造成极大开销(虽然有时候这种约束在检查数据一致性方面性能较优)
		3、外键约束通常还意味着会造成更多额外的锁
		4、综上所述,外键会造成极大开销和可能造成一些并发困扰,如果单单使用外键做约束建议在程序中实现

##tip:
	1、mysql通过SHOW VARIABLES LIKE '%%'来查看系统变量属性
	2、使用SHOW TABLE STATUS命令（在MySQL 5.0以后的版本中，也可以查询INFORMATION_SCHEMA中对应的表）显示表的相关信息。SHOW TABLE STATUS LIKE '%%'
	3、schema的大小写敏感也与平台有关(windows不敏感，unix敏感)所以在定义schema时养成一个良好的命名习惯可以减少不少麻烦
	4、对于一个select语句，查询缓存-->解析查询-->优化执行查询。如果缓存中可以找到对应查询，服务器就不需要继续去解析查询。
	5、DELIMITER ; 用来制定SQL的分隔符(mysql shell)
	6、SHA1()和MD5()是强加密函数，设计目标是最大限度消除冲突。可以使用如FNV64()函数作为哈希函数，这是移植自Percona Server的函数，可以以插件的方式在任何MySQL版本中使用，哈希值为64位，速度快，且冲突比CRC32()要少很多
	7、可以了解一下后缀索引suffix index。例如，找到某个域名的所有电子邮件地址。MySQL原生并不支持反向索引，但是可以把字符串反转后存储，并基于此建立前缀索引。可以通过触发器来维护这种索引。
	8、	SHOW CREATE TABLE tableName 来查看建表script
		SHOW INDEX FROM tableName查看table index 信息
		ANALYZE TABLE tableName查看table
	9、OPTIMIZE TABLE tableName 来组织和整理table数据
	10、推荐一些小工具:Percona Toolkit
		Percona Toolkit中的pt-query-advisor能够解析查询日志、分析查询模式，然后给出所有可能存在潜在问题的查询，并给出足够详细的建议
	11、按照ID(主键)顺序进行查询和插入效率会高于随机修改
	12、SHOW FULL PROCESSLIST 可以查看mysql服务的所有连接
		Sleep
		Query
		Locked
		Analyzing and statistics
		Copying to tmp table [on disk]
		The thread is
		Sending data
	13、EXPLAIN EXTENDED SQL;SHOW WARNINGS; 查询执行计划优化重构后的SQL
	14、直到mysql5.7,select in(selec)仍然是一个很糟糕的选择。会造成表多重关联，外层表数据量极大时会造成极大性能问题;EXISTS和IN并不是一个好的解决问题的方法;所以两者建议均不适用
	15、DISTINCT 和ORDER BY会造成冲突,order by 的属性在 SELECT DISTINCT 中必须存在。
	16、数据和索引的统计信息存储在存储引擎层;
	17、一些极大数据的更新或者删除操作时,建议加上limit 分批操作提升容错率
	18、子查询得出的单个"数据"可以被当作一个常数;而子查询得出的结果集被当作临时表;常数往往会比结果集有更高的效率
	19、GREATEST(10, 20, 30)---30 返回最大值
       LEAST(10, 20, 30)---10 返回最小值
       类似的方法有GREATEST()、LENGHT()、ISNULL()、NULLIFL()、IF()和COALESCE() 
    20、SELECT VERSION() from DUAL 查看mysql版本。！！！不同版本的mysql内部引擎优化天差地别。记住大致思路，千万不要去扣字眼钻牛角尖。
    21、distinct:可能有时会迫使select放弃索引,可以使用分段查询,先select结果集后distinct
    22、SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;查看当前正在执行的事务,方便跟踪阻塞等待以及死锁问题;
    	SHOW PROCESSLIST; 查看当前mysql进程。
    	可以通过 kill PID 杀死正在执行的事务和对应的进程
	23、INSERT INTO.....ON DUPLICATE KEY UPDATE  insert当产生冲突时候update
		INSERT INTO `community`.`car`(`id`,`tag`)values ('鲁Q782DM','湖北往返车辆')on duplicate key update  tag='湖北往返车辆';

##next:
	1、JOIN USING()的用法
	2、GROUP BY WITH ROLLUP
	3、LIMIT OFFSET
	4、Sphinx
	5、Percona Toolkit
	

	select * from t1 where com1 in () and  con2 and con3 in()

2、效率问题
select *,(select group_concat() from t2 where t2.t1Id = t1.id) from t1 where id in ()

select * from t1 where id in()
left join t2 on t2.t1Id = t1.id
