#给出了一个例子，然后让根据这个例子，在输入的数组中找出第 k 大的素数，输入数组可能 包含不是素数的数字


#二叉树求和，找出数字只和等于 21 的数组下边，要求复杂度要小于 o(logn) 
	1、先排序后遍历

#一个顺序递增的数组，内含重复的数，现查找一个给定的数在不在数组，在的话给出最后一个出现的 index
	1、二分查找
##	如果数组从中间断开翻转

#数组中第 k 大的数c 数组中 top K 的数字 OK
	1、排序	2、如果K小的话,可以标记多个元素,一次遍历完成	3、剪枝法(类似于快排)

#http 状态码/
  + 1xx：表示服务器收到请求，正在处理 100 continue
  + 2xx：处理正常，
  		200一切正常 						201成功,创建了新资源(create)				202请求已接受,处理未完成（accept）
  + 3xx：表示重定向 	
  		301资源被永久移动					302重定向(临时移动)
  + 4xx：客户端错误，
  		400请求无效						401请求用户进行身份验证						403鉴权失败(forbidden)	404资源未发现(not found)	
  		405操作不被允许(请求的方法被禁止)		407用户需要代理授权							408请求超时(time out)		409资源产生冲突(PUT请求可能会发生conflict)
  		410资源曾经可能存在过(现在找不到了)	413请求实体过大,无法返回(entity too large)	415无法处理的媒体格式(unsupported type)
  + 5xx：服务器错误
  		500服务器内部错误					502从上游服务器获得无效相应Bad Gateway		503服务不可用				504	代理的问题,从上游服务器获取数据超时Gateway Time-out
  		505不支持的HTTP协议

#HTTP方法
	基于REST风格,
	GET设计的初衷,希望用于从请求获取资源。所以通过路径去访问资源。
	POST则是向指定的资源提交要处理的数据。POST可以传递和处理多种类型的数据。
	PUT更倾向于覆盖指定资源
		新建一条记录的话就用post，
		更新一条记录的话就用put
	DELETE删除指定的资源
	OPTIONS用于检查服务器状态和性能

	哪些请求方法是幂等的。多次操作不会造成破坏稳定性的后果
		GET是幂等的。
		POST方法不是幂等的。
		PUT是幂等的
		DELETE是幂等的。

#大文件内存排序问题。
	100 G 文件 8G 内存 如何排序。

	找出最大的 K 个数	找出重复数


#HTTPS 如何做到安全
	Https是指Http Over TLS，意思是在加密的Http报文协议。它主要解决Http协议使用明文传输数据带来的几个问题：窃听风险、篡改风险和身份冒充风险


#MySQL 存储引擎区别
	INNODB:
		支持事务。事务执行必然会消耗性能。
		根据聚簇索引结构组织表结构
		聚簇索引查询大多数情况快于MYISAM
		索引和表数据一起存储在表空间里
	MYISAM:	
		不支持事务、行锁、回滚、外键和原子性操作。只支持表锁(服务器级别锁)。
		堆表。磁盘上存储对应的.frm定义、.MYD数据、.MYI索引。
		通常的select性能优于INNODB。
		聚簇索引和普通索引一样,只能起到唯一性约束的作用。
		会保留表的count总数,用于汇总查询select count(*) from table
		支持全文索引
#MySQL 索引结构优缺点
	BTREE:数据放在子叶节点,正向排序优化。
	I/O少
#Varchar(2000)创建索引会怎样
	Specified key was too long; max key length is 3072 bytes, Time: 0.012000s
	在mysql5.7中索引列的最大长度为3072个字节


#mysql 分库分表
##	分区表是一个独立的逻辑表,底层有多个物理子表构成。
## 	分区表索引也是在底层物理表上加完全相同的索引。
##	在存储引擎看来,分区表底层和每个物理独立表没有什么不同。索引分区是在服务器级别实现的。
##	在进行SELECT/UPDATE/INSERT/DELETE操作时,分区层先打开并锁住所有的底层表,然后确定对应哪个分区修改这条记录,再将记录写入对应底层表。
		需要注意的是,这里的锁全表,并不是申请表级别排他锁。INNODB会自主实现行级锁。和普通查询没什么不同。
##	MySQL还支持键值、哈希和列表分区，这其中有些还支持子分区
##	索引也是按照分区的子表定义(没有全局索引)
##	无法使用外键约束
###		表非常大以至于无法全部都放在内存中，或者只在表的最后部分有热点数据，其他均是历史数据。
###		分区表的数据更容易维护。例如，想批量删除大量数据可以使用清除整个分区的方式。另外，还可以对一个独立分区进行优化、检查、修复等操作。
###		分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。
###		备份和独立恢复不同分区
##分区表的使用
###	PARTITION分区子句中可以使用各种函数。但有一个要求，表达式返回的值要是一个确定的整数，且不能是一个常数。
	分区表达式不能返回NULL！！NULL会将数据分发至默认分区。否则会扫描多余分区
###	查询能够过滤到大多数分区的查询。运用分区列进行查询
###	分区列和索引列匹配
##缺点	无法单独使用各个子表
		所有分区表需要使用相同的存储引擎
		在操作时锁全表可能是个非常耗费性能的操作。会明显影响根据聚簇索引查询数据。
##人为分表
	暂时不做讨论


#两个线程，一个只能存有数组 1、3、5 和另一个存有 2、4、6，然后通过调度，最终结果输出 123456

#链表逆序	OK
	
##	每隔K逆序

#jvm 垃圾回收算法

#	synchroized
##	lock 与 synchroized 的区别

##	sychronzied 是可重入锁吗
	是

##synchroized static 的作用范围
	作用于static方法时,获得的锁是类锁,也就是锁定的是整个类。
	synchronized作用于非static方法时,锁定的是实例对象本身。

#非阻塞 io 的具体实现

#数据库前缀索引
	alter table xw_user_applyloan add index uname( old_kefuid(4) )
	无法在GROUP BY 和ORDER BY使用索引
	可测试选择性(大多数经验公式)
##	全列选择性
		SELECT COUNT(DISTINCT column_name) / COUNT(*) FROM table_name;
## 测试某一长度前缀的选择性
 		SELECT COUNT(DISTINCT LEFT(column_name, prefix_length)) / COUNT(*) FROM table_name;
#进程线程协程区别

#io 多路复用原理，在 redis 和 mysql 的实现

#两个单链表求和	OK

#4c8G 机器 1000qps 怎么配置机器和线程池

#删除链表中重复的结点
	用一个MAP记录
#2.设计一个限流工具，每 5s 允许一个请求，多的请求丢弃 3.设计一个限流工具，在第 1，6，11，16 秒允许一个请求，多的丢弃 4.设计一个限流工具，在第 1，6，11，16 秒允许一个请求，多的排队等待

#简单工厂，抽象工厂，方法工厂的区别
##简单工厂
	就是一个生产产品的工厂
##抽象工厂
	生产工厂的工厂
##方法工厂
	可以生产多种产品的工厂。只定义动作,具体生产过程和产品让其继承者去进行
#java 线程池的有哪些参数，以及意义

#ctrl c 过程;

#去除重复列表;

#单链表求和;

#两个链表分别表示两个数，对这两个链表加和，产生一个新的链表 OK

#输入一个 int 数组，返回一个数组，其中奇数都在左边，偶数都在右边 OK

#StackOverflowError 和 OutOfMemoryError 的区别和分别处理
##	StackOverflowError
	栈区异常。一般表示递归深度超过了当前最深
	也可能是当前线程太多了
##	堆和栈、甚至方法区和直接内存都有可能出现
	栈区和StackOverflowError相似。问题的不同表述


#在一个有序但元素可能重复的数组中，输入一个目标值，返回这个目标值的左边界和右边界。 [1,1,2,2,2,2,2,4,5]，得到 2 的左右边界。

#归并排序

#介绍项目中用到的 jvm 命令，jmap,jstack,jstat


#Oracle、MySQL、SQL SERVER
##	SQL SERVER 
		windwos平台下。
		创建临时集with()
		开窗函数over
		分析工具、执行计划、锁跟踪

##	ORACLE
		重量级。
		可以更加灵活定义索引和表是否分区
## mysql
		不支持ROW_NUM。推荐使用自增序列

#排序数组中计算重复数字出现的次数

#kafka 的原理，以及使用中遇到的问题


#手写堆排序

##	把所有的排序算法捋一遍

#两个字符串 a 和 b，找 a 中包涵 b 的最短的字符串

#二叉搜索树找第 K 大

#选择排序 OK

#java 的 array 跟 list 的比较，底层原理上的
	ArrayList 底层就是array
	LinkedList会维护一个Node
#sql 问每门课程都大于 80 分的学生名字
	select name from table where name not in (select name from table where score <80)
	select name,min(score) as m from table group by name  having m >=80 
#java 编程题，a、反转一句英语的所有单词:hello world - > world hello

#mysql 在可重复读的情况下，如何避免幻读
	InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）解决幻读
	是一种行锁的变种
		简单来说,就是INNODB在每一行数据后面有两个隐藏列(行创建时间和过期时间)。其实都是系统版本号。在开始一个事务后,系统版本号都会递增作为事务版本号。
		所以在读取数据时,存储引擎只会查找早于当前版本的行数据。删除同理,删除的数据如果晚于当前版本号，对于事务也不可见。
#算法题:遍历树，求从根节点到叶子节点和为某值的路径。

#链表快排
#Xss csrf
##XSS
	跨域脚本网络攻击:通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本（可能是js、hmtl代码块等）
	盗用cookie、恶意植入广告
##csrf
	跨站点请求伪造
	解决方案:1、token认证(可实现动态认证)	2、head令牌	3、指定请求来源

CSRF：需要用户先登录网站A。利用网站本身漏洞	,获取 cookie。
XSS：不需要登录。利用合法操作篡改网站内容

#重定向，调转的前后端实现
	request.getRequestDispatcher(url).forward(request, response);
	response.sendRedirect(url);

#ssl

#归并排序

#介绍一下观察者模式
	发布订阅模式。解耦。
	对象状态或者行为作出改变,需要通知订阅者。被观察对象维护一个订阅者列表
#二叉搜索树找第 K 大
#用固定长度的数组，实现循环队列

#b+树跟平衡二叉树的比较
	顺序访问之争,ORDER优化
	