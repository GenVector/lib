#	计算机网络
##	目前普通理解的五层模型 
	物理层->数据链路层->网络层->传输层->应用层
##	网络层的所有工作都是为了寻址 IP 路由器
	192.168 IPv4协议规定的内网地址之一 家用路由器内网地址
##	传输层的所有工作都是为了数据交换 TCP UDP
##	数据链路层通过MAC寻址 
	交换机、帧包装、帧传输、帧同步 帧的差错恢复 流量控制
#	------------------------物理层----------------------
##	双工、半双工、单工通信概念
#	-------------------------数据链路层协议-------------------------

#	-------------------------网络层协议-------------------------
#	ARP协议
	即地址解析协议,是根据IP地址获取MAC地址的一个网络层协议。其工作原理如下：ARP首先会发起一个请求数据包,数据包的首部包含了目标主机的IP地址,然后这个数据包会在链路层进行再次包装,生成以太网数据包,最终由以太网广播给子网内的所有主机,每一台主机都会接收到这个数据包,并取出标头里的IP地址,然后和自己的IP地址进行比较,如果相同就返回自己的MAC地址,如果不同就丢弃该数据包。ARP接收返回消息,以此确定目标机的MAC地址;与此同时,ARP还会将返回的MAC地址与对应的IP地址存入本机ARP缓存中并保留一定时间,下次请求时直接查询ARP缓存以节约资源。
#	路由协议
	首先通过IP协议来判断两台主机是否在同一个子网中,如果在同一个子网,就通过ARP协议查询对应的MAC地址,然后以广播的形式向该子网内的主机发送数据包;如果不在同一个子网,以太网会将该数据包转发给本子网的网关进行路由。网关是互联网上子网与子网之间的桥梁,所以网关会进行多次转发,最终将该数据包转发到目标IP所在的子网中,然后再通过ARP获取目标机MAC,最终也是通过广播形式将数据包发送给接收方。而完成这个路由协议的物理设备就是路由器,路由器扮演着交通枢纽的角色,它会根据信道情况,选择并设定路由,以最佳路径来转发数据包。
#	IP协议:
	网络层引入了IP协议,制定了一套新地址,使得我们能够区分两台主机是否同属一个网络,这套地址就是网络地址,也就是所谓的IP地址。IP协议将这个32位的地址分为两部分,前面部分代表网络地址,后面部分表示该主机在局域网中的地址。如果两个IP地址在同一个子网内,则网络地址一定相同。为了判断IP地址中的网络地址,IP协议还引入了子网掩码,IP地址和子网掩码通过按位与运算后就可以得到网络地址。
##	IPv4地址为32位二进制代码,我们习惯将32位地址中每8位用等效的十进制数字表示。
###	A类:1->126
	其中A类网络前8位位网段号,后24位是网络号。
	掩码:255.0.0.0
	网段数:126—->(27-2)
	网段包括1-126。不可为0,0的含义是本网络,127为保留地址,作为本地与进程之间通信的环回地址)
	主机数:28*28*28-2-->(0->255)*(0->255)*(0->255)-2
	//-2表示,不存在一个主机IP地址除了网段全为0,表示网络地址。例如50.0.0.0表示网段为50的网络地址。另外全为1表示该网络上的所有主机。说明一下这里的1是指二进制中的1,例如50.255.255.255。
	私有地址段:10.0.0.0->10.255.255.255

###	B类:128->191
	掩码:255.255.0.0
	网段数:26*28-->(191-127)*(0->255)
	主机数:28*28-2
	主机数同理,需要去除掉全是0和全是1的地址。例如128.10.255.255。
	私有地址段:172.16.0.0->172.131.255.255

###	C类:192->223
	掩码: 255.255.255.0
	网段数:25*28*28 -1 --> (223-191)*(0->255)*(0->255)-1   //-1的原因在于,192.0.0是不可被指派的网络地址。
	主机数:28-2 --> 1->254
	私有地址段:192.168.0.0->182.168.255.255
	回送地址:127. 

##	IPV6

#	-------------------------传输层协议-------------------------

#	传输层协议:TCP与UDP
#	TCP(Transmission Control Protocol,传输控制协议)
##	三次握手和四次挥手
	基于连接的协议,也就是说,在正式收发数据前,必须和对方建立可靠的连接。一个TCP连接必须要经过三次握手才能建立。
	这三次对话的简单过程:主机A向主机B发出连接请求数据包:“我想给你发数据,可以吗？”,这是第一次对话;主机B向主机A发送同意连接和要求同步(同步就是两台主机一个在发送,一个在接收,协调工作)的数据包:“可以,你什么时候发？”,这是第二次对话;主机A再发出一个数据包确认主机B的要求同步:“我现在就发,你接着吧！”,这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步,经过三次“对话”之后,主机A才向主机B正式发送数据。
		1>第一次握手:建立连接时,客户端发送syn包(syn=x)到服务器,并进入SYN_SENT状态,等待服务器确认;SYN:同步序列编号(Synchronize Sequence Numbers)。
		2>第二次握手:服务器收到syn包,必须确认客户的SYN(ack=x+1),同时自己也发送一个SYN包(syn=y),即SYN+ACK包,此时服务器进入SYN_RECV状态;
		3>第三次握手:客户端收到服务器的SYN+ACK包,向服务器发送确认包ACK(ack=y+1),此包发送完毕,客户端和服务器进入ESTABLISHED(TCP连接成功)状态,完成三次握手。
	四次挥手:
		1>客户端进程发出连接释放报文,并且停止发送数据。释放数据报文首部,FIN=1,其序列号为seq=u(等于前面已经传送过来的数据的最后一个字节的序号加1),此时,客户端进入FIN-WAIT-1(终止等待1)状态。 TCP规定,FIN报文段即使不携带数据,也要消耗一个序号。
		2>服务器收到连接释放报文,发出确认报文,ACK=1,ack=u+1,并且带上自己的序列号seq=v,此时,服务端就进入了CLOSE-WAIT(关闭等待)状态。TCP服务器通知高层的应用进程,客户端向服务器的方向就释放了,这时候处于半关闭状态,即客户端已经没有数据要发送了,但是服务器若发送数据,客户端依然要接受。这个状态还要持续一段时间,也就是整个CLOSE-WAIT状态持续的时间。
		3>客户端收到服务器的确认请求后,此时,客户端就进入FIN-WAIT-2(终止等待2)状态,等待服务器发送连接释放报文(在这之前还需要接受服务器发送的最后的数据)。
		4>服务器将最后的数据发送完毕后,就向客户端发送连接释放报文,FIN=1,ack=u+1,由于在半关闭状态,服务器很可能又发送了一些数据,假定此时的序列号为seq=w,此时,服务器就进入了LAST-ACK(最后确认)状态,等待客户端的确认。
		5>客户端收到服务器的连接释放报文后,必须发出确认,ACK=1,ack=w+1,而自己的序列号是seq=u+1,此时,客户端就进入了TIME-WAIT(时间等待)状态。注意此时TCP连接还没有释放,必须经过2∗∗MSL(最长报文段寿命)的时间后,当客户端撤销相应的TCB后,才进入CLOSED状态。
		6>服务器只要收到了客户端发出的确认,立即进入CLOSED状态。同样,撤销TCB后,就结束了这次的TCP连接。可以看到,服务器结束TCP连接的时间要比客户端早一些。
#	UDP(User Data Protocol,用户数据报协议)是与TCP相对应的协议 无状态协议
	它是面向非连接的协议,它不与对方建立连接,而是直接就把数据包发送过去！ UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。比如,我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常,其实“ping”命令的原理就是向对方主机发送UDP数据包,然后对方主机确认收到数据包,如果数据包是否到达的消息及时反馈回来,那么网络就是通的。例如,在默认状态下,一次“ping”操作发送4个数据包。大家可以看到,发送的数据包数量是4包,收到的也是4包(因为对方主机收到后会发回一个确认收到的数据包)。这充分说明了UDP协议是面向非连接的协议,没有建立连接的过程。正因为UDP协议没有连接的过程,所以它的通信效果高;但也正因为如此,它的可靠性不如TCP协议高。QQ就使用UDP发消息,因此有时会出现收不到消息的情况。 

#	port 端口
		端口号(port)是传输层协议的内容
		端口号是一个2字节16位的整数
		端口号用来标识一个进程，告诉操作系统，当前这个数据交给哪一个程序进行解析
		IP地址 + 端口号能标识网络上的某一台主机的某一个进程。
		进程有唯一的pid标识，端口号也能标识进程;
			一个进程可以绑定多个端口号。
			一个端口号不能被多个进程绑定。一个端口号只能被一个进程占用。
#	socket嵌套字
	套接字是网络编程中的一种通信机制，是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。
	概念比较抽象和复杂。TCP/UDP通信基本单元。一个TCP连接数据处理也并非三次握手这么简单的事情。通常我们在处理TCP连接时候,各种工具使用帮助我们屏蔽了socket、包括缓冲区等处理过程。
##	TCP通信过程
	server socket() -> bind() -> listen() -> read() -> write() -> read() -> close()
	client socket() -> connect() //三次握手 -> write() -> read() -> close()
##	进程间通信(IPC)方式
	1、管道(包括无名管道和命名管道)
 	2、消息队列;
 	3、信号量;
 	4、共享存储。
 	5、……( Socket和Streams支持不同主机上的两个进程IPC)。
#	-------------------------应用层协议-------------------------
#	Telnet远程登录协议
#	FTP文件传输协议
#	HTTP协议
	HTTP是基于TCP协议！
	http请求 request由三部分组成,分别是:请求行、消息报头、请求正文
	http response 响应也是由三个部分组成,分别是:状态行、消息报头、响应正文
##	八种请求方法
	GET 
	POST 
	PUT 类似于POST 用于替换服务器指定资源
	DELETE 删除 用于删除服务器指定资源
	OPTIONS 检测方法 只用于检测服务器性能或状态
	CONNECTION
	TRACE
	HEAD

##	content-length 定义http content 长度

##	Content-Type
###	常见的媒体格式类型如下：
    text/html ： HTML格式
    text/plain ：纯文本格式 
    text/xml ：  XML格式
    image/gif ：gif图片格式    
    image/jpeg ：jpg图片格式 
    image/png：png图片格式
###	以application开头的媒体格式类型
	application/xhtml+xml 	 			XHTML格式
	application/xml  		 			XML数据格式
	application/atom+xml     			Atom XML聚合格式    
	application/json 		 			JSON数据格式
	application/pdf       	 			pdf格式  
	application/msword  	 			Word文档格式
	application/octet-stream 			二进制流数据(如常见的文件下载)
	application/x-www-form-urlencoded	form表单数据被编码为key/value格式发送到服务器(表单默认的提交数据的格式)另外一种常见的媒体格式是上传文件之时使用的：
	multipart/form-data					需要在表单中进行文件上传时,就需要使用该格式
     	！！！需要加charset。示例: "text/html;charset=utf-8"

### HTTP URL 不区分大小写 header KEY不区分大小写

##	code 
	1* 信息性状态码 101 Upgrade 比如GET升级WebSocket
	2* 成功状态码
	3* 重定向错误状态码 //301 302 重定向
		301 redirect: 301 永久性转移(Permanently Moved) 资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址
		302 redirect: 302 暂时性转移(Temporarily Moved) 表示旧地址的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址
	4* 客户端错误状态码 //400 参数错误 401 请求要求身份验证 404 no tFound  413 资源违法 415资源类型不匹配 等常见异常
	5* 服务器错误状态码 //500 服务器内部错误 502/504 中间网关、代理错误/超时

#	WebSocket 应用层协议 基于TCP 有状态的长连接 http升级而来
	Request URL: ws://121.40.165.18:8800/
	Request Method: GET
	Status Code: 101 Switching Protocols
	Connection: Upgrade
	Upgrade: websocket

###	WS 为何需要使用http升级(兼容问题?)?

#	SSL、TLS与HTTPS、WS 加密协议
##	http、FTP、DNS、等都是应用层协议
##	TLS与SSL在传输层与应用层之间对网络连接进行加密
##	SSL协议位于TCP/IP协议与应用层协议之间,为数据通讯提供安全支持
##	ws->TLS->wss
##	http->SSL->https

##	http2


#	互联网、因特网、万维网
	互联网 > 因特网 > 万维网

##	互联网：由通信的设备,如计算机、手机等,组成的网络。互联网是一个逻辑概念,即使仅有两台机器,不论用何种技术使其彼此通信,也叫互联网

##  目前所有局域网都是以太网 以太网是局域网技术
##  因特网(Internet)目前全球最大的一个电子计算机互联网

### Internet是一组全球信息资源的总汇。INTERNET是由于许多小的网络(子网)互联而成的一个逻辑网,每个子网中连接着若干台计算机(主机)。Internet以相互交流信息资源为目的,基于一些共同的协议,并通过许多路由器和公共互联网而成,它是一个信息资源和资源共享的集合
###	因特网并不是全球唯一的互联网络。例如在欧洲,跨国的互联网络就有“欧盟网”(Euronet),“欧洲学术与研究网”(EARN),“欧洲信息网”(EIN),在美国还有“国际学术网”(BITNET)
##  因特网 HTTP协议下 都是用了万维网 包括WS协议


#   服务器
##  应用服务器(Tomcat作为servlet容器 处理动态资源请求 负责将HTTP request 适配为servlet可解析的类型规范) 
##  HTTP服务器(Apache、NGINX等 作为静态HTTP资源服务器)
##  通常应用服务器和http服务器共同使用 分别负责处理HTTP静态资源和处理动态资源
##	KONG API GATEWAY
	基于NGINX 提供包括HTTP基本认证、密钥认证、CORS、TCP、UDP、文件日志、API请求限流、请求转发及NGINX监控等基本功能

#	DNS协议
##	DNS 解析从后往前解析 根域服务器 . -> 权威域名服务器com/cn(一级域名) -> baidu.com. -> www.baidu.com. 直到找到最终IP
##	流程
	1>cache 首先判断client缓存寻址
	2>etc/hosts 如果没有缓存会先去找主机hosts配置文件
	3>根域服务器(13个IP地址) 然后根据 寻址
	4>顶级(一级)域名服务器

##	一级域说明
	.com (商业机构);
	.net (从事互联网服务的机构);
	.org (非赢利性组织);
	.com.cn (国内商业机构);
	.net.cn (国内互联网机构);
	.org.cn (国内非赢利性组织);
###	另外,顶级域名是可以注册的

##	A记录 IP指向

##	CNAME 别名指向
	 CNAME的目标主机地址只能使用主机名，不能使用IP地址
##	MX记录
##	NS记录

#   cookie与跨域问题总结
##  跨域是浏览器限制 所以这里指的域名仅仅针对浏览器 具体哪一层DNS负责解析这个域名 服务端和浏览器都不关心
### 引申一下就是 每一层代理协议之间是隔离的 无法相互识别对方的规则 所以在请求链路中的安全校验也是相对的
### 代理只负责把数据传递给下一层协议 并做一些限制
##  cookie存储在浏览器 由服务端解析。cookie的跨域问题同理 不关心DNS解析 只要符合域名规则 可携带cookie
##  cookie属性详细解析
### domain
### path
### key/value
### max age(expire)
### setcookie方法成功后,只能在下次请求域中通过读取cookie。cookie是从request中header读取的,你response还没返回给客户端当然读不到

##  header -> host origin refer 属性
### Host 客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。在任何类型请求中,request都会包含此header信息。
### Origin用来说明请求从哪里发起的,包括,且仅仅包括协议和域名。这个参数一般只存在于CORS跨域请求中,可以看到response有对应的header：Access-Control-Allow-Origin。
###	Referer 告知服务器请求的原始资源的URI,其用于所有类型的请求,并且包括：协议+域名+查询参数(注意,不包含锚点信息)。可能包含ID或密码等敏感信息,如果写入referer,则可能导致信息泄露。

##	跨域问题解决
    //允许携带的header中属性 支持 * 通配符 ajax cookie跨域访问中 * 无法支持 需要显示指定可以携带哪些header信息
    res.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_HEADERS, "Content-Type,X-Requested-With");
    //是否允许携带cookie
    res.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_CREDENTIALS, "true");
    //支持的跨域名访问 ajax cookie跨域访问中 * 无法支持 ORIGIN 属性只能设置 一个 需要服务端手动配置 白名单匹配
    res.headers().set(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN, "*");

##	代理可以代替服务端去设置允许跨域问题 代理有拦截和处理请求setResponse的能力
##	浏览器还有很多限制 AJAX 跨域携带cookie 白名单问题 允许携带的header

#	网关、网桥、路由器、交换机
##	路由器
	路由器的两大功能是路由选择和路由转发。
	路由器具有多个输入端口和多个输出端口,
	路由器从某个输入端口收到的分组,按照指定规则,将分组从某个合适的输出端口转发到输出网络(下一个路由器,路由器依次转发到最终的目的地址)。
###	电脑上网的原理
	一、电脑要在一个子网中,子网里面有一个是路由器负责跟外面的网络通信。
	二、电脑要有自己的ip地址,用于在网络层寻址。
	三、电脑要有自己的mac地址,用于在子网内寻址。
	四、要有dns服务器,用于dns解析。
###	家用路由器的工作原理(NAT)
	一、家用路由器自己构建了一个子网,然后它作为该子网的路由同外界通信,当然这个子网是以nat的方式构建的。
	二、路由器有一个ip地址,这个是在Internet上的ip地址。电脑的ip地址是路由器构建的子网的地址。
	三、电脑有自己的mac地址用于在家用路由器构建的子网中寻址。
	四、家用路由器负责dns转发,将电脑的dns请求转发给网络中相应的dns服务器。
##	交换机
	两者都是连接互联网的设备,它们之间主要区别就是,交换机发生在网络的第二层数据链路层,而路由器发生在第三层网络层。
	这个区别是两者各自工作方式的根本区别。路由器可以根据IP地址寻找下一个设备,可以处理TCP/IP协议,而上一篇我们讲过交换机是根据MAC地址寻址的。
	交换机是分配网络数据,路由器可以给网络分配IP地址,分配给你地址而且可以随时通过地址过来找到你。
	路由器可以在不同时间内把一个IP分配给多台主机使用。交换机是通过MAC地址和识别各个不同的主机。
	可以通俗地解释一下网关、网桥、路由器和交换机之间的关系。交换机类似用于扩展,网桥用于连接两个网络,交换机的出现替代了网桥。网关用于连接内外网，路由器替代了网关。
##	bridged模式
	Bridged模式下,就是将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。
	在桥接的作用下,类似于把物理主机虚拟为一个交换机,所有桥接设置的虚拟机连接到这个交换机的一个接口上,物理主机也同样插在这个交换机当中,所以所有桥接下的网卡与网卡都是交换模式的,相互可以访问而不干扰,所有网卡都可以独立工作。
	在桥接模式下,虚拟机ip地址需要与主机在同一个网段,如果需要联网,则网关与DNS需要与主机网卡一致。	
##	NET模式
	NAT模式借助虚拟NAT设备和虚拟DHCP服务器,使得虚拟机可以联网。家用路由器工作原理。
##	VPN 虚拟专用网
