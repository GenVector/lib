#给出了一个例子，然后让根据这个例子，在输入的数组中找出第 k 大的素数，输入数组可能 包含不是素数的数字


#二叉树求和，找出数字只和等于 21 的数组下边，要求复杂度要小于 o(logn) 
	1、先排序后遍历

#一个顺序递增的数组，内含重复的数，现查找一个给定的数在不在数组，在的话给出最后一个出现的 index
	1、二分查找
##	如果数组从中间断开翻转

#数组中第 k 大的数c 数组中 top K 的数字 OK
	1、排序	2、如果K小的话,可以标记多个元素,一次遍历完成	3、剪枝法(类似于快排)

#http 状态码/
  + 1xx：表示服务器收到请求，正在处理 100 continue
  + 2xx：处理正常，
  		200一切正常 						201成功,创建了新资源(create)				202请求已接受,处理未完成（accept）
  + 3xx：表示重定向 	
  		301资源被永久移动					302重定向(临时移动)
  + 4xx：客户端错误，
  		400请求无效						401请求用户进行身份验证						403鉴权失败(forbidden)	404资源未发现(not found)	
  		405操作不被允许(请求的方法被禁止)		407用户需要代理授权							408请求超时(time out)		409资源产生冲突(PUT请求可能会发生conflict)
  		410资源曾经可能存在过(现在找不到了)	413请求实体过大,无法返回(entity too large)	415无法处理的媒体格式(unsupported type)
  + 5xx：服务器错误
  		500服务器内部错误					502从上游服务器获得无效相应Bad Gateway		503服务不可用				504	代理的问题,从上游服务器获取数据超时Gateway Time-out
  		505不支持的HTTP协议

#HTTP方法
	基于REST风格,
	GET设计的初衷,希望用于从请求获取资源。所以通过路径去访问资源。
	POST则是向指定的资源提交要处理的数据。POST可以传递和处理多种类型的数据。
	PUT更倾向于覆盖指定资源
		新建一条记录的话就用post，
		更新一条记录的话就用put
	DELETE删除指定的资源
	OPTIONS用于检查服务器状态和性能

	哪些请求方法是幂等的。多次操作不会造成破坏稳定性的后果
		GET是幂等的。
		POST方法不是幂等的。
		PUT是幂等的
		DELETE是幂等的。

#大文件内存排序问题。
	100 G 文件 8G 内存 如何排序。

	找出最大的 K 个数	找出重复数


#HTTPS 如何做到安全
	Https是指Http Over TLS，意思是在加密的Http报文协议。它主要解决Http协议使用明文传输数据带来的几个问题：窃听风险、篡改风险和身份冒充风险


#MySQL 存储引擎区别
	INNODB:
		支持事务。事务执行必然会消耗性能。
		根据聚簇索引结构组织表结构
		聚簇索引查询大多数情况快于MYISAM
		索引和表数据一起存储在表空间里
	MYISAM:	
		不支持事务、行锁、回滚、外键和原子性操作。只支持表锁(服务器级别锁)。
		堆表。磁盘上存储对应的.frm定义、.MYD数据、.MYI索引。
		通常的select性能优于INNODB。
		聚簇索引和普通索引一样,只能起到唯一性约束的作用。
		会保留表的count总数,用于汇总查询select count(*) from table
		支持全文索引
#MySQL 索引结构优缺点
	BTREE:数据放在子叶节点,正向排序优化。
	I/O少
#Varchar(2000)创建索引会怎样
	Specified key was too long; max key length is 3072 bytes, Time: 0.012000s
	在mysql5.7中索引列的最大长度为3072个字节


#mysql 分库分表
##	分区表是一个独立的逻辑表,底层有多个物理子表构成。
## 	分区表索引也是在底层物理表上加完全相同的索引。
##	在存储引擎看来,分区表底层和每个物理独立表没有什么不同。索引分区是在服务器级别实现的。
##	在进行SELECT/UPDATE/INSERT/DELETE操作时,分区层先打开并锁住所有的底层表,然后确定对应哪个分区修改这条记录,再将记录写入对应底层表。
		需要注意的是,这里的锁全表,并不是申请表级别排他锁。INNODB会自主实现行级锁。和普通查询没什么不同。
##	MySQL还支持键值、哈希和列表分区，这其中有些还支持子分区
##	索引也是按照分区的子表定义(没有全局索引)
##	无法使用外键约束
###		表非常大以至于无法全部都放在内存中，或者只在表的最后部分有热点数据，其他均是历史数据。
###		分区表的数据更容易维护。例如，想批量删除大量数据可以使用清除整个分区的方式。另外，还可以对一个独立分区进行优化、检查、修复等操作。
###		分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。
###		备份和独立恢复不同分区
##分区表的使用
###	PARTITION分区子句中可以使用各种函数。但有一个要求，表达式返回的值要是一个确定的整数，且不能是一个常数。
	分区表达式不能返回NULL！！NULL会将数据分发至默认分区。否则会扫描多余分区
###	查询能够过滤到大多数分区的查询。运用分区列进行查询
###	分区列和索引列匹配
##缺点	无法单独使用各个子表
		所有分区表需要使用相同的存储引擎
		在操作时锁全表可能是个非常耗费性能的操作。会明显影响根据聚簇索引查询数据。
##人为分表
	暂时不做讨论


#两个线程，一个只能存有数组 1、3、5 和另一个存有 2、4、6，然后通过调度，最终结果输出 123456

#链表逆序	OK
	
##	每隔K逆序

#jvm 垃圾回收算法

#	synchroized
##	lock 与 synchroized 的区别

##	sychronzied 是可重入锁吗
	是

##synchroized static 的作用范围
	作用于static方法时,获得的锁是类锁,也就是锁定的是整个类。
	synchronized作用于非static方法时,锁定的是实例对象本身。

#非阻塞 io 的具体实现

#数据库前缀索引
	alter table xw_user_applyloan add index uname( old_kefuid(4) )
	无法在GROUP BY 和ORDER BY使用索引
	可测试选择性(大多数经验公式)
##	全列选择性
		SELECT COUNT(DISTINCT column_name) / COUNT(*) FROM table_name;
## 测试某一长度前缀的选择性
 		SELECT COUNT(DISTINCT LEFT(column_name, prefix_length)) / COUNT(*) FROM table_name;
#进程线程协程区别

#io 多路复用原理，在 redis 和 mysql 的实现

#两个单链表求和	OK

#4c8G 机器 1000qps 怎么配置机器和线程池

#删除链表中重复的结点
	用一个MAP记录
#2.设计一个限流工具，每 5s 允许一个请求，多的请求丢弃 3.设计一个限流工具，在第 1，6，11，16 秒允许一个请求，多的丢弃 4.设计一个限流工具，在第 1，6，11，16 秒允许一个请求，多的排队等待

#简单工厂，抽象工厂，方法工厂的区别
##简单工厂
	就是一个生产产品的工厂
##抽象工厂
	生产工厂的工厂
##方法工厂
	可以生产多种产品的工厂。只定义动作,具体生产过程和产品让其继承者去进行
#java 线程池的有哪些参数，以及意义

#ctrl c 过程;

#去除重复列表;

#单链表求和;

#两个链表分别表示两个数，对这两个链表加和，产生一个新的链表 OK

#输入一个 int 数组，返回一个数组，其中奇数都在左边，偶数都在右边 OK

#StackOverflowError 和 OutOfMemoryError 的区别和分别处理
##	StackOverflowError
	栈区异常。一般表示递归深度超过了当前最深
	也可能是当前线程太多了
##	堆和栈、甚至方法区和直接内存都有可能出现
	栈区和StackOverflowError相似。问题的不同表述


#在一个有序但元素可能重复的数组中，输入一个目标值，返回这个目标值的左边界和右边界。 [1,1,2,2,2,2,2,4,5]，得到 2 的左右边界。

#归并排序

#介绍项目中用到的 jvm 命令，jmap,jstack,jstat


#Oracle、MySQL、SQL SERVER
##	SQL SERVER 
		windwos平台下。
		创建临时集with()
		开窗函数over
		分析工具、执行计划、锁跟踪

##	ORACLE
		重量级。
		可以更加灵活定义索引和表是否分区
## mysql
		不支持ROW_NUM。推荐使用自增序列

#排序数组中计算重复数字出现的次数

#kafka 的原理，以及使用中遇到的问题


#手写堆排序

##	把所有的排序算法捋一遍

#两个字符串 a 和 b，找 a 中包涵 b 的最短的字符串

#二叉搜索树找第 K 大

#选择排序 OK

#java 的 array 跟 list 的比较，底层原理上的
	ArrayList 底层就是array
	LinkedList会维护一个Node
#sql 问每门课程都大于 80 分的学生名字
	select name from table where name not in (select name from table where score <80)
	select name,min(score) as m from table group by name  having m >=80 
#java 编程题，a、反转一句英语的所有单词:hello world - > world hello

#mysql 在可重复读的情况下，如何避免幻读
	InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）解决幻读
	是一种行锁的变种
		简单来说,就是INNODB在每一行数据后面有两个隐藏列(行创建时间和过期时间)。其实都是系统版本号。在开始一个事务后,系统版本号都会递增作为事务版本号。
		所以在读取数据时,存储引擎只会查找早于当前版本的行数据。删除同理,删除的数据如果晚于当前版本号，对于事务也不可见。
#算法题:遍历树，求从根节点到叶子节点和为某值的路径。

#链表快排
#Xss csrf
##XSS
	跨域脚本网络攻击:通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本（可能是js、hmtl代码块等）
	盗用cookie、恶意植入广告
##csrf
	跨站点请求伪造
	解决方案:1、token认证(可实现动态认证)	2、head令牌	3、指定请求来源

CSRF：需要用户先登录网站A。利用网站本身漏洞	,获取 cookie。
XSS：不需要登录。利用合法操作篡改网站内容

#重定向，调转的前后端实现
	request.getRequestDispatcher(url).forward(request, response);
	response.sendRedirect(url);

#ssl

#归并排序

#介绍一下观察者模式
	发布订阅模式。解耦。
	对象状态或者行为作出改变,需要通知订阅者。被观察对象维护一个订阅者列表
#二叉搜索树找第 K 大
#用固定长度的数组，实现循环队列

#b+树跟平衡二叉树的比较
	顺序访问之争,ORDER优化


各位面试官下午好,我叫郭诗雨,很高兴能来参加这次面试,我面试的职位是金融市开发处程序开发岗。我2017年毕业于西北工业大学信息管理与信息系统专业。毕业后前后就职于浪潮通用软件有限公司和北京睿企信息科技有限公司。
浪潮主要项目经历是一些企业级ERP财务项目,主要难点在于大量精度数据计算和汇总报表生成
后来在北京主要做的项目是一些TO G TO B的区域大数据项目。主要是海量数据获取、汇集和处理、展示。
主要技术栈有Java语言、spring相关框架、MySQL、SQL SERVER等主流关系型数据库,也有MongoDB、HBASE、Redis等非关系型数据库使用;
部署是docker、K8S容器化部署。在技术上对于精确数据计算和金融类强一致性有一定开发经验。
学习和钻研能力比较好,
独立负责过不少中小型项目
#智慧社区警务产品介绍:
##主要功能用途:多路数据汇合、数据治理、数据展示。
	主要服务包括:爬虫服务、算法服务、pipeline服务、后端服务和前端服务。主要负责pipeline和后端服务、数据库等。
##kafka
	摄像头爬虫->kakfa->Java服务->kafka->算法。
	kafka使各个模块异步解耦。
	retry机制,最大努力通知。没有回滚操作(可以有,进行一致性校验)
	比较平稳,没有涉及到削峰
##mysql：定时切换表、分表、静态统计
	平台主要负责数据展示。包括实时报警、实时感知、异常状态提醒、关系型数据库数据量极大。采用动静态结合数据统计优化查询。
##Redis用途:
	扫描数据量过大,一致性要求不高的查询。引入Redis缓存。因为表非常大,查询优化只能达到一秒左右。
	集群建容器化部署,redis负责集群间缓存共享,spring security SecurityContextHolder。
	CAS只负责认证,不负责授权。登录时候也先找Redis,Redis没有再去找MySQL
	一致性和方法幂等性实现:对于爬虫服务,处理过的数据就不再进行第二次处理。防止重复消费。
##MongoDB
	文档服务器,存放实时感知数据:数据类型较为复杂、没有关联,且会有多个服务读写和监听。因为是一写多读,不存在资源争抢。
##山东省示范项目

#纵横超搜产品
##HBASE 实现数据汇集为一X一档。根据唯一主键聚合一类数据
##MYSQL 没有什么特别
##ES 索引表
##
集群环境下，Session管理的几种手段

Session复制
缺点：集群服务器间需要大量的通信进行Session复制，占用服务器和网络的大量资源。
由于所有用户的Session信息在每台服务器上都有备份，在大量用户访问的情况下，会出现服务器内存不够Session使用的情况。

Session绑定
在整个会话期间，用户所有的请求都在同一个服务器上处理，即Session绑定在某台特定服务器上，保证Session总能在这台服务器上获取。

利用Cookie记录Session
缺点:受Cookie大小限制，如果用户关闭Cookie，访问就不正常了。
这个大部分网站还是使用这种方式的。

Session服务器
独立部署Session服务器统一管理Session，应用服务器每次读写Session时，都访问Session服务器。

socket
服务器端：
– 申请一个socket (socketWatch)用来监听的
– 绑定到一个IP地址和一个端口上
– 开启侦听，等待接授客户端的连接
– 当有连接时创建一个用于和连接进来的客户端进行通信的socket(socketConnection)
– 即续监听,等侍下一个客户的连接
客户端：
– 申请一个socket(socketClient)
– 连接服务器（指明IP地址和端口号）
	